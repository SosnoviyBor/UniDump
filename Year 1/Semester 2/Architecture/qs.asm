
TITLE ЛР_1_1


IDEAL	;
MODEL small	
STACK 256	; Директива – розмір стека
;
     DATASEG
exCode db 0
message db "Hello world!",10,13,'$' ;
;
CODESEG
Start:

mov ax,@data; @data ідентифікатор, що створюються директивою model 
mov ds, ax	; 
mov es, ax	; 
;
mov dx, offset message

mov ah,09h
int 21h	; Виклик функції DOS 9h

mov ah,01h

int 21h	; Виклик функції DOS 21h

mov ah,4ch
mov al,[exCode]	;
int 21h	
end Start




TITLE ЛР_1_3
;------------------------------------------------------------------------------
;ЛР  № 1-3
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1            
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
; 	
; I. ЗАГОЛОВОК ПРОГРАМИ
IDEAL ; Директива - тип Асемблера tasm
MODEL small ; Директива - тип моделі пам&#39;яті
STACK 512 ; Директива - розмір стеку в байтах
;---------------------
MACRO M_Init
	mov ax, @data ; ax &lt;- @data
	mov ds, ax ; ds &lt;- ax
	mov es, ax ; es &lt;- ax
	xor si, si
ENDM M_Init
;---------------------
MACRO M_Exit
	mov ah,4ch
	mov al,[exCode]	; отримання коду виходу
	int 21h	; виклик функції DOS 4ch        
ENDM  M_Exit
;---------------------
DATASEG
exCode    db 0
message   db "Hello world!",10,13,'$' ; Рядок символів для виводу на екран
message1  db "Hello world! From proc1",10,13,'$' ; Рядок символів для виводу на екран
message2  db "Hello world! From proc2",10,13,'$' ; Рядок символів для виводу на екран
;---------------------
CODESEG
	PROC main
	M_Init

		
		mov dx, offset message
		
		mov ah,09h
		int 21h	; Виклик функції DOS 9h
		
		call HelloWorld1
		
		mov dx, offset message2
		call HelloWorld2

mov ah,01h
int 21h
	
	M_Exit                        
    ENDP main

 
    PROC HelloWorld1
   
        mov dx, offset message1
		mov ah,09h
		int 21h	; Виклик функції DOS 9h
		ret
    ENDP HelloWorld1 

	;
    PROC HelloWorld2

		mov ah,09h
		int 21h	; Виклик функції DOS 9h
		ret
    ENDP HelloWorld2

END main                                
                                                  
                                        


1. Опишіть принципи мікропрограмного керування.
2. Основи двійкової системи числення, системи числення з основою 16, побітові логічні операції, види кодування у обчислювальних машинах. 
3. Опишіть принципи побудови машини Фон Неймана.
4. Опишіть структурну схему типової комп’ютерної системи.
5. Опишіть загальну організацію пам’яті комп’ютерної системи, види пам’яті.
6. Розкрийте термін «Архітектура системи команд».
7. Розкрийте термін «Програмна модель».
8. Опишіть периферійні пристрої комп’ютерної системи.
9. Розкрийте етапи створення програми з використанням Асемблера tasm або іншого Асемблера, що вивчається.
10. Розкрийте основну відмінність високорівневих мов програмування і Асемблера у контексті зв’язку з архітектурою комп’ютера. 
11. Опишіть технологію створення комп'ютерної програми на Асемблері.
12. Як архітектурні елементи комп’ютерної системи зв’язані з кодом Асемблера? 
13. Опишіть технологію асемблювання вихідного коду, які процеси відбуваються і які файли утворюються. 
14. Напишіть прапорці команди tasm для асемблювання вихідного коду. Які можливості вони надають?
15. Що відбувається на етапі асемблювання вихідного коду. Які команди викликаються (на прикладі TASM), які їх параметри?
16. Що відбувається на етапі компонування програми (TLINK). Які команди використовуються у командному рядку і які їх параметри?
17. Яку команду треба набрати для виклику Turbo Debugger (TD)? Що відображається на робочому вікні TD, як дослідити дамп пам’яті?
18. Опишіть спрощену структуру системної плати комп’ютерів і вкажіть призначення основних елементів схеми.

TITLE V сod 2.1
;------------------------------------------------------------------------------

IDEAL
MODEL SMALL
STACK 512

MACRO M_Init		; Початок макросу 
mov	ax, @data		; ax <- @data
mov	ds, ax			; ds <- ax
mov	es, ax			; es <- ax
ENDM M_Init		; Кінець макросу


DATASEG
exCode db 0

CODESEG
Start:	
M_Init
;----------- Variant 1. 
						;
	mov AX, 0B800h 			; 1
	mov ES, AX 				; 2
	mov BX, 0 				; 3. 
	mov SI, 2000			; 4. 
	mov DI, 3998			; 5. 
	mov [word ES:BX], 3130h		; 6. С
	
	mov AH,01h 			
	int 21h 
	mov [word ES:SI], 3130h		; 

	mov AH,01h 				
	int 21h 	
	mov [word ES:DI], 3130h	; 10. 
	
	mov AH,01h 				; 9
	int 21h 
Exit:
     mov ah,4ch
     mov al,[exCode]
     int 21h
    end Start
 




TITLE ЛР_2_2
;------------------------------------------------------------------------------
;ЛР  № 2-2 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
IDEAL   
MODEL small 
STACK 256   
MACRO M_Init ; Початок макросу
mov ax,@data ; ax <- @data 
mov ds,ax ; ds <- ax
mov es,ax ; es <- ax
ENDM M_Init ; Кінець макросу
 
DATASEG
exCode db 0
rect_line db 'T', 012h, 'e', 012h, 's', 012h, 't', 012h, 'T', 012h
db ' ', 012h, 'e', 012h, 's', 012h, 't', 012h, 'M', 012h, 'e', 012h, '!', 012h ;
db 8 dup ("", 00h, 012h) 

 
CODESEG
Start:
M_Init
mov ax, 0B800h
mov es, ax 
mov bx, 0 ; у
mov di, 324 ; у 
 
main_loop:
    mov cx, 40 ; 
    mov si, offset rect_linI
    rep movsb ; I,

    add di, 120 ;
    inc bx ; 
    cmp bx, 10 ; 
    jne main_loop ; 
Exit:

mov ah, 04Ch 
mov al, [exCode] ; Вхідний параметр для функції 4ch
int 21h
END Start


		

Перелік запитань для підготовки до лабораторної роботи 
1. Які шини системної плати ПК ви знаєте? Опишіть їх призначення. 
2. Опишіть загальну архітектуру мікропроцесора І8086.  Як ця архітектура повязана з сучасними ПК?
3. Опишіть типи, регістри і організацію пам’яті мікропроцесора І8086. 
4. На які групи можна розділити систему команд мікропроцесора 8086? Наведіть приклади команд із кожної групи. 
5. Наведіть приклади виконання команд, які впливають на окремі прапорці  (СF, OF, PF, SF, ZF, AF).
6. Опишіть команди передачі даних Асемблера мікропроцесора І8086, користуючись довідковою таблицею. Назвіть операції, операнди, прапорці, на які впливає команда. Наведіть приклади.
7. Опишіть арифметичні і логічні команди Асемблера мікропроцесора І8086, користуючись довідковою таблицею. Назвіть операції, операнди, прапорці, на які впливає команда. Наведіть приклади.
8. Опишіть команди Асемблера мікропроцесора І8086 для управління процесом виконання програми, користуючись довідковою таблицею. 
9. Опишіть команди Асемблера  мікропроцесора І8086 для процедур і переривань. 
10. Наведіть приклад реалізації програмного розгалуження, організації програмного циклу з використанням Асемблера.




TITLE ЛР_3_1
;------------------------------------------------------------------------------
;ЛР  № 3-1 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__

;----------------I. ЗАГОЛОВОК ПРОГРАМИ------------------------
IDEAL
MODEL SMALL
STACK 512
; 	II. МАКРОСИ 	 	
; Складний макрос для ініціалізації 
MACRO M_Init		;Початок макросу 
mov	ax, @data	; ax <- @data
mov	ds, ax	; ds <- ax
mov	es, ax	; es <- ax 
ENDM M_Init

;--------------------III. ПОЧАТОК СЕГМЕНТА ДАНИХ--------------
DATASEG
; Оголошення двовимірного експериментального масиву 16х16 
array2Db	db 7, 8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8
db  7, 7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,7
db  7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,7
db  7, 8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,7


arr_def1 dw 3, 0 , 0 , 0 , 0 , 0 , 0 , 0


array2Dw	dw 8, 8 ,8 ,8 ,8 ,8 ,8 ,8
dw  8, 8 ,8 ,8 ,8 ,8 ,8 ,8
dw  8, 8 ,8 ,8 ,8 ,8 ,8 ,8
dw  7, 7 ,7 ,8 ,8 ,7 ,7 ,7
dw  7, 7 ,7 ,8 ,8 ,7 ,7 ,7
dw  7, 7 ,7 ,8 ,8 ,7 ,7 ,7
dw  7, 7 ,7 ,8 ,8 ,7 ,7 ,7
dw  7, 7 ,7 ,8 ,8 ,7 ,7 ,7
; Для вирівнювання у дампі
arr_def2 dw 3, 0 , 0 , 0 , 0 , 0 , 0 , 0

; Оголошення двовимірного масиву 4х4 
array2Dd	DD  34925, 34925 ,34925 ,34925
DD  34925, 30583 ,30583 ,34925
DD  34925, 30583 ,30583 ,34925
DD  34925, 34925 ,34925 ,34925

arr_def3 DW 3, 0 , 0 , 0 , 0 , 0 , 0 , 0

; Рядки повідомлень
msg_love DB "Max Natali$"
msg_asm DB "Assembler AUTS $"
msg_vb	DB "Variable in byte"
; Оголошення змінних
v1_byte	DB 11111111b ; однобайтова змінна
arr_def4	DB 3, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
msg_vw	DB	"Variable in word"
v2_word	DW 0aaffh ; змінна 1 машинне слово
arr_def5	DW 3, 0 , 0 , 0 , 0 , 0 , 0
msg_vdd	DB "Variable in dd" ; 4-байтова змінна
v3_dword	DD 011ff11ffh 
arr_def6	DW 3, 0 , 0 , 0
exCode	DB 0 

CODESEG
;----------------------VI. ПОЧАТОК СЕГМЕНТА КОДУ-------------------
Start:
M_Init
; Способи адресації за Рудаковим-Фiногеновим----------------------


mov ax,03h	;
;.
mov [DS:[00h]], ax ;
mov [DS:[01h]], ax  ;
mov [DS:[02h]], ax  ;
mov [DS:[03h]], ax  ;
mov [DS:[04h]], ax  ;
mov [DS:[05h]], ax  ;
mov [DS:[06h]], ax  ;
mov [DS:[07h]], ax
mov [v2_word], ax
;

mov al, 02h	; 
mov bx, 08h	
mov [bx], al		; Х 
inc bx		
mov [bx], al	; 
inc bx
mov [bx], al	; За 
inc bx
mov [bx], al	; inc bx
mov [bx], al	; inc bx
mov [bx], al	; inc bx
mov [bx], al	; inc bx

mov bp, 01h	
mov cx, [bp]	; Е

; I
mov bx, 04h
mov [di], bx	;M(DS*16+DI)<-BX inc di
mov [di], bx ;M(DS*16+DI+1)<-BX
inc di
mov [di], bx ;M(DS*16+DI+2)<-BX
inc di
mov [di], bx ;M(DS*16+DI+3)<-BX
inc di
mov [di], bx ;M(DS*16+DI+4)<-BX
inc di
mov [di], bx ;M(DS*16+DI+5)<-BX
inc di
mov [di], bx ;M(DS*16+DI+6)<-BX
inc di
mov [di], bx ;M(DS*16+DI+7)<-BX

mov si, 01h	
mov ax, [si]	;.


;
mov al, 9	; 
mov bx, 20h	; Г
mov si, 0h	; Г
mov [array2Db+si+bx], al
inc si
mov [array2Db+si+bx], al;
inc si
mov [array2Db+si+bx], al;
add bx, 10h
mov si, 0h
mov [array2Db+si+bx], al;
inc si
mov [array2Db+si+bx], al; 
inc si
mov [array2Db+si+bx], al;

mov ax, [BP+SI]	; Наприклад:
mov cx, [BP+DI]
mov dx, [BX+SI]
mov dx, [BX+DI]


mov [array2Db+si+bx+3], al;

mov si, 0	; І
mov dl, [array2Db+si]	
mov si, 1	; А. 
mov dh, [array2Db+si]	; 
mov si, 2	; 
mov cl, [array2Db+si]	; c

mov ax, 1	;(aх<-1)
mov ah, 0ffh	;( ah <-0ffh)
mov al, 0aah	;( al <-0aah)
mov bx, 02h	;(bx<-02h) 
mov bh, 011h
mov bl, 0aah
mov dx, '7'	;dx (dx<-"ASCII код знака 7")
mov si, 4	;si (si<-4)
mov di, 04h	;di (di<-04h) 
mov di, 11101110b


; 
push ds	; Розміщення в стеку змісту регістру ds, зміст пам’яті
; M(SSx16-SP*2)<-ds
push ss
push es
; Приклад. Відновлення значення СР
pop ds	; Відновлення зі стека змісту регістру cs
pop ss	; Аналогічна операція,зміст пам’яті M(SSx16+SP*2)<-ds pop es
; pop cs Не дозволено


Exit:

mov ah, 04Ch 
mov al, [exCode] ; Вхідний параметр для функції 4ch
int 21h
END Start



Перелік запитань для підготовки до лабораторної роботи
1. Як програмно (TD) визначається ефективна адреса змінної (початку масиву)?
2. Опишіть пряму адресацію, синтаксис, використання. Поясніть на прикладі.
3. Опишіть регістрову адресацію, синтаксис, використання. Поясніть на прикладі коду.
4. Опишіть індексну адресацію, синтаксис, використання. Поясніть на прикладі коду.
5. Опишіть базову адресацію з ВХ, синтаксис, використання. Поясніть на прикладі коду.
6. Опишіть базову адресацію з ВР, синтаксис, використання. Поясніть на прикладі коду.
7. Опишіть базово-індексну адресацію, синтаксис, використання. Поясніть на прикладі коду.
8. Опишіть базово-індексну адресація зі зміщенням, синтаксис, використання. Поясніть на прикладі коду.
9. Опишіть стекову адресацію, синтаксис, використання. Поясніть на прикладі коду.
10. Назвіть перелік регістрів загального призначення архітектури Intel 8086. Опишіть призначення регістрів, особливості. Розкрийте поняття розрядності регістрів. 
11. Назвіть перелік сегментних регістрів архітектури Intel 8086.  Яка розрядність сегментних регістрів?
12. Опишіть оперативну пам’ять, адресу і зміст за адресою. Як здійснюється сегментація пам’яті 8086, навіщо розроблений цей механізм?
13. Що таке логічна адреса, адреса початку сегменту, зміщення у сегменті, фізична адреса операнду. Як визначається фізична адреса операнду? 
14. Опишіть призначення сегменту даних, сегменту стеку, сегменту коду. Синтаксис їх опису в Асемблері. Як можна визначити адресу початку сегментів з використанням TD? Поясніть на прикладі коду.
15. Опишіть синтаксис змінної, чисельного масиву, масиву символів у Асемблері. Як визначити фізичну адресу змінної, початку масиву? 


 

TITLE ЛР_4_1
;------------------------------------------------------------------------------
;ЛР  № 4-1 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
;----------------I. ЗАГОЛОВОК ПРОГРАМИ-----------------
IDEAL
MODEL SMALL
STACK 512

MACRO M_Exit	

int 21h
ENDM M_Exit	


MACRO M_Init		
mov ax, @data	; ax <- @data
mov  ds, ax	; ds <- ax
mov  es, ax	; es <- ax
ENDM M_Init	; 

DATASEG

array2Dw dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh 
dw 0AABBh, 0CCEEh ,0AABBh ,0CCEEh, 0AABBh, 0CCEEh ,0AABBh ,0CCEEh
array2Dwlen = $-array2Dw

arrayRes dw '*' dup (64)
arrayReslen = $ - arrayRes
msg_asm DB "Assembler  $"
exCode db 0
CODESEG
;	I. ПОЧАТОК СЕГМЕНТА КОДУ
Start:
M_Init
; Дослідження базової адресації для доступу до стека
    mov bp, 0200h; Вершина стека
    mov [word bp], 0A0Ah

    lea si, [array2Dw]
    mov ax, [array2Dwlen]
	mov cx, ax
stack1:
    mov ax, [si] 
	add si, 2
    push ax 
    loop stack1


   lea si, [arrayRes]
   mov cx, 64

stack2:
   pop ax 
   mov [si], ax 
   add si, 2
   loop stack2
;
   nop
;*і*
   mov ah, 048h ; Ознака переривання
   mov bx, 02h ; Розмір нової ділянки у параграфі
;*Parameters for output*
; CF = 0 if ok
; AX Адреса нового сегмента пам’яті
; CF = 1 Ознака помилки виконання переривання
; AX = 7 Ознака помилки
; AX = 8 Ознака малого обсягу пам’яті
; BX розмір нової ділянки
   int 21h
; Перенесення масиву до нової ділянки пам’яті
   mov es, ax	; Ініціалізація сегментного регістру новою адресою
   mov cx, 8	; Визначення розміру нової ділянки масиву множенням
   mov ax, 8
   mul cx
   mov cx, ax	; Підготовка циклу до виконання, кількість ітерацій
   xor di, di
   lea si, [array2Dw] ; Ефективна адреса масиву до індексного рег.

mem1:
   mov dx, [si]	; Н
   mov [es:di], dx		;За 
   add si, 2	; П
   add di, 2
   loop mem1

nop 
nop
;**Зміна розміру ділянки. Вхідні параметри
mov ah, 04Ah	;Ознака команди
mov bx, 01h	;Новий розмір
; ES адреса сегмента, що буде змінюватися
;***Вихідні параметри***
; CF = 1 if not ok
; AX = 7 if memory blocks is destroyed
; AX = 9 Некоректна адреса
; AX = 8 Невистачає памяті
; BX розмір нової пам’яті
int 21h

nop 
nop
;**Звільнення пам’яті. Вхідні параметри*** 
mov ah, 049h ; command mark
; ES адреса блоку, що звільняється
;***Вихідні параметри***
; CF = 0 ok
; CF = 1, AX = 7 if memory blocks is destroyed
; CF = 1, AX = 9 Некоректна адреса

int 21h
Exit:
mov ah,4ch 
mov al,[exCode] 
int 21h
end Start




Перелік запитань для підготовки до лабораторної роботи 

1. Опишіть загальну схему роботи «переривання» в архітектурі комп’ютера. Які види переривань ви знаєте?
2. Розкрийте поняття програмного переривання, переривання DOS i BIOS, як використовується це переривання. Поясніть на прикладі коду, користуючись довідковою літературою.
3. Розкрийте поняття апаратного переривання. Що таке масковані й немасковані переривання. Опишіть процес переривання мікропроцесора 8086 користуючись структурною схемою.
4. Яке призначення контролера переривань, як здійснюється програмне управління контролером? 
5.	Що таке таблиця векторів переривань, у якій ділянці пам’яті вона знаходиться?

 

 
TITLE ЛР_5_1
;------------------------------------------------------------------------------
;ЛР  № 5-1 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
;----------------I. ЗАГОЛОВОК ПРОГРАМИ------------------------------------------
IDEAL
MODEL SMALL
STACK 512
; 	II. МАКРОСИ 	
; 2.2. Складний макрос для ініціалізації 
MACRO M_Init		;Початок макросу 
mov	ax, @data	; ax <- @data
mov	ds, ax	; ds <- ax
mov	es, ax	; es <- ax
ENDM M_Init	; Кінець макросу

;	III. ПОЧАТОК СЕГМЕНТА ДАНИХ
DATASEG
; 
array2Db db 7, 8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8
db 7, 7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,0 ,7
db 7, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,7 ,7
db 7, 8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,8 ,7 ,7


arr_def1 dw 3, 0 , 0 , 0 , 0 , 0 , 0 , 0
; Ану
arr_dup2D db 0100h DUP(4)
; Д
arr_def11 dw 3, 0 , 0 , 0 , 0 , 0 , 0 , 0
arr_rnd1 db 2, 3, 0 , 2, 1, 9, 7, 2
variant db 3
; 
arr_def2 dw 3, 0 , 0 , 0 , 0 , 0 , 0 , 0
no_ziro db "Variable is NOT ziro", 10, 13, '$' 
is_ziro db "Variable IS ziro", 10, 13, '$' 
out_of db "out OF constr", 10, 13, '$' 
arr_def6 dw 3, 0 , 0 , 0
exCode db 0

;----------------------VI. ПОЧАТОК СЕГМЕНТА КОДУ-----------------
CODESEG
Start:
M_Init
;--

    mov si, 0	; 
    mov di, 0	; 
    mov dl, [arr_rnd1+di]	;DL <- arr_rnd1[0]
    mov al, 10h
    mov dh, [variant]
    mul dh	; 
    mov bx, ax	; Index for 2D of array2Db, in vertical 
    mov [array2Db+bx+si+3], dl


    mov cx, 8	; 
    mov si, 0	; I
    mov di, 0	;
horisontal:
    mov dl, [arr_rnd1+di]	; DL <- arr_rnd1[0] 
    mov al, 10h
    mov dh, [variant]
    mul dh	; AX<-(variant*10h)
    mov bx, ax	; Index for 2D of array2Db, in vertical
    inc si	; Inc for 2D of array2Db, in gorizontal
    inc di	; Inc for 1D of arr_rnd1, in gorizontal 
    mov [array2Db+bx+si+3], dl
    loop horisontal

;
    mov cx, 8
    mov si, 0	; Index for 2D of [array2Db] and [arr_rnd1], in gorizontal

horisontal_1:
mov dl, [arr_rnd1+si]	; DL <- arr_rnd1[0] 
    mov al, 10h
    mov dh, 5	; For testing refactoring
    mul dh	; AX<-(variant*10h)
    mov bx, ax		; Index for 2D of array2Db, in vertical 
    inc si	; inc for 2D of array2Db, in gorizontal
    mov [array2Db+bx+si+3], dl 
    loop horisontal_1

    mov dh, [variant]	; Coutrer of cicle vertical init 
vertical_1:
    cmp dh, 11	; The 11 is vertical coord of left bottom of array 8x8 
    jz main_exit	; !!! MAIN EXIT
    mov al, 10h	; It is simple mult for vertical coord of strings
    mul dh	; AX<-(variant*10h), execute of mult, result in AX 
    mov bx, ax	; BX<-AX Index for [array2Db], in vertical coord 
    mov cx, 8	; Counter of cicle gorizontal init
    mov si, 0	; Ziro to index of [array2Db] and [arr_rnd1] in gorizontal 
horisontal_2:
    mov dl, [arr_rnd1+si]	; DL <- [arr_rnd1[si]]
    inc si	; inc index of [array2Db] in gorizontal
    mov [array2Db+bx+si+3], dl ;si and 3 are connect to gorizontal coord in 8x8 
    loop horisontal_2

    inc dh	; inc coord vertical
    jmp vertical_1	; come back 
main_exit:

    mov cx, 0
    cmp cx, 0 
    jz next_z1

    mov ah, 09h 
    lea dx, [no_ziro] 
    int 21h
    jmp next_2 ; go to end of constuct IF 
next_z1:
;
    mov ah, 09h
    lea dx, [is_ziro] 
    int 21h
next_2:
    mov ah, 09h 
    lea dx, [out_of] 
    int 21h
    mov ax, 0

    test ax, 10000000b 
    jne next_z2

    mov ah, 09h
    lea dx, [no_ziro] 
    int 21h
    jmp next_1 
next_z2:

    mov ah, 09h
    lea dx, [is_ziro] 
    int 21h
next_1:
    mov ah, 09h 
    lea dx, [out_of] 
    int 21h

;

    cld	; Обнулення прапорця напрямку, прямий 
    lea si, [array2Db]	; Завантаження відн. адреси джерела 
    lea di, [arr_dup2D] ; Завантаження відн. адреси приймача 
    mov cx, 100h	; Визначення кількості повторень
    rep	movsb	; Завантаження



    mov al, 03h
    mov cx, 100h ;
    mov si, 0
ptr_1:
    mov [ds:[si]], al
    inc si
    loop ptr_1


    mov al, 05h
    mov cx, 100h ; За
    mov si, 0
ptr_2:
    mov [array2Db+si], al
    inc si
    loop ptr_2

Exit:
    mov ah,4ch 
    mov al,[exCode]
    int 21h 
end Start

	

Перелік запитань для підготовки до лабораторної роботи

1. Що таке порти введення-виведення, як забезпечується програмний доступ до них у мікропроцесорі 8086? 
2. Яку кількість портів введення-виведення підтримує мікропроцесор 8086? Як використати Асемблер для управління зовнішніми пристроями через порти введення-виведення.   
3. Опишіть способи використання масочних операцій  з командами IN та OUT для управління окремими бітами.
4. Які інтерфейси комп’ютерної систем актуальні нині? Опишіть їх призначення і назву.  
5. Які команди Асемблера  8086 використовуються для програмування процедур?
6. Які передаються параметри процедур Асемблера  8086?
7. Як реалізуються цикли у програмах на Асемблері Intel 8086? Поясніть на прикладі коду. 
8. Як відбувається програмний доступ до периферійних пристроїв комп’ютера?


TITLE ЛР_6_2  COM1
;------------------------------------------------------------------------------
;ЛР  № 6-2 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:  
; Дата:         __/__/__
;---------------------------------
IDEAL

MACRO M_Exit	
mov	ah, 04Ch 
int	21h	
ENDM

MACRO M_Init	
mov	ax, @data	
mov	ds, ax	
mov	es, ax	
ENDM

MODEL small 
STACK 256 

DATASEG

old_offset	DW ? ;  
old_seg	DW ? ; се
mesg db "Group number:",9,"1",10
db 13,10,13,"Members:",10,13,10,13
db "Test1",10,13
db "Test1",10,13
db "Test1",10,13,'$'

team = 1 ; 
custom_int dw ? ; о

CODESEG
Start:
M_Init	
mov [custom_int], 51 ; номер необхідного переривання
mov	di, [custom_int]	; Вхідний параметр для процедури 
call GIntV	

mov	[old_offset], bx ; Запам’ятовуємо зміщення обробника
mov	[old_seg], es ; Запам’ятовуємо сегмент обробника

;
mov di, [custom_int]
mov dx, offset int_custom ; У DX записуємо зміщення нашої кастомної процедурикоду
mov ax, seg int_custom ; Записуємо логічну адресу сегменту коду
mov es, ax 
call SintV

; -------- Виклик 
int 51

; ---- Повернення вектора переривання до початкового стану---
; Вхідні параметри для процедури SIntV
mov	di, [custom_int] 
mov	dx, [old_offset] ; Записуємо зміщення, 
mov	ax, [old_seg] ; Записуємо сегмент, що був спочатку в  
mov	es, ax
call SIntV
xor	al, al
M_Exit	



;------------------------------------------------------------------------------
; Призначення: Установка на номер вектора нової функції обробника.
; Функціонально: до пам’яті що відповідає вектору заносимо ефективну адресу і адресу сегменту нового обробника переривань
; На вхід:DI - номер переривання де буде нова процедура
;  DX - ефективна адреса нового обробника
;  ES - адреса сегмента нового обробника
; На вихід: ---
;------------------------------------------------------------------------------
; Автор:  
; Дата:         __/__/__
;---------------------------------

PROC SIntV
cli ; Заборона апаратних переривань

; Поміщаємо в стек регістри, значення яких хочемо залишити недоторканним
push ax
push di
push ds

xor	ax, ax ; AX <- 0
mov ds, ax	; DS <- 0
shl	di, 2 ; DI <- DI * 4
mov	[ds:[di]], dx ; Перезаписуємо зміщення у векторі переривання 
mov	[ds:[di + 2]], es ; Перезаписуємо сегмент у векторі переривання 

; Відновлюємо попередні значення регістрів зі стеку
pop	ds
pop	di
pop	ax

sti ; Дозвіл апаратних переривань
ret	
ENDP 


;------------------------------------------------------------------------------
; Процедура - кастомний обробник для переривання. 
; Вхід: --
; Вихід: --
;------------------------------------------------------------------------------
; Автор:  
; Дата:         __/__/__
;---------------------------------
PROC int_custom

mov ax, 03h
int 10h ; Очищення екрану
mov ah, 09h ; Ф-я виводу рядка на екран
mov dx, offset mesg ; DX <- зміщення змінної mesg
int 21h ; Переривання DOS 21h
; Код закінчення апаратного переривання
mov	al, 20h
out	20h, al
iret	; Вихід з процедури обробника переривання
ENDP 

;------------------------------------------------------------------------------
; Призначення: Отримання логічної адреси процедури (функції) обробки переривання за номером вектора переривання
; Вхід:DI <- номер вектора переривання
; Вихід:BX,ES <- Ефективна адреса та сегмент процедури (функції) обробки переривання
;------------------------------------------------------------------------------
; Автор:  
; Дата:         __/__/__
;---------------------------------

PROC GIntV
; Поміщаємо в стек регістри, значення яких хочемо залишити недоторканним
push ax
push di

xor	ax, ax ; AX <- 0
mov	es, ax ; ES <- 0
shl	di, 2 ; DI <- DI * 4
mov	bx, [es:[di]] ; В BX записуємо 
mov	ax, [es:[di + 2]] ; В AX записуємо 
mov	es, ax	
pop	di
pop	ax
ret
ENDP 
END Start 


Перелік запитань для підготовки до лабораторної роботи
1. Рішення яких проблем дозволяє вирішити маскування переривань?
2. Опишіть загальну схему обробки переривання?
3. Як забезпечується відновлення обчислень після обробки переривання?
4. Для чого в обробнику переривань передбачений тимчасову заборону на прийом запитів переривання? Коли він вводиться і знімається?
5. Що таке вектор переривання і як він зв'язаний з функцією обробки переривання? 
6. Назвіть призначення та склад системної плати. 
7. Яку функцію виконує Northern Bridge (Північний міст), Southern Bridge (Південний міст)? Як змінений системний дизайн у сучасних комп’ютерах.  
8. Опишіть механізм конвеєрної обробки команд у процесорі. 
9. Опишіть принцип суперскалярної архітектури процесора. 
10. Дайте характеристику периферійної шини USB. 
11. Опишіть типи, призначення регістрів і організацію пам’яті мікропроцесора 8086. 
12. Перерахуйте особливі функції регістрів загального призначення архітектури Intel 8086. 
13. Перерахуйте сегментні регістри архітектури Intel 8086. Для чого призначені регістри, які їх особливості?
14. Як здійснюється сегментація пам’яті 8086, що дозволяє покращити цей механізм?



TITLE ЛР_7_0 
;------------------------------------------------------------------------------
;ЛР  № 7-0 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
IDEAL
MODEL   small
STACK   256

DATASEG
	string  db      254     ;string variable def. There is max len ,
  	str_len db      0      
   	db 254 dup ('*')        ; Буфер
    	system_message_1   DB "Input somthing\  "  ,'$'
	display_message_0  DB "------------menu bagin--------", 13, 10, '$'
	display_message_1  DB "c - for count",   13, 10,  '$'
	display_message_3  DB "q - for exit",    13, 10,  '$' 
	display_message_4  DB "----------programm for lab is END !!! - for exit", 13, 10,  '$'
	display_message_5  DB "------------menu end--------", 13, 10, '$'
	message  DB ?
	test_message_1  DB "COUNT",         13, 10,  '$' 
	test_message_3  DB "EXIT",           13, 10,  '$'

CODESEG

Start:
     mov ax, @data            
     mov ds, ax

Main_cусle: 

	call display1

	call input_foo

	cmp ax, 063h ; c ascii =63h
	je Count
	cmp ax, 071h ; q ascii =71h
	je  Exit
	jmp Main_cусle

Count:
	mov dx, offset test_message_1
	call display_foo  ; any foo
	jmp Main_cусle

   
Exit:
   mov dx, offset display_message_4  
   call display_foo
   mov ax,04C00h          
   int 21h                
 ;-------------------------------------------------------
PROC display1
	mov dx, offset display_message_0
	call display_foo
	mov dx, offset display_message_1
	call display_foo
	mov dx, offset display_message_3
	call display_foo
	mov dx, offset system_message_1
	call display_foo
	mov dx, offset display_message_5
	call display_foo
	ret
ENDP display1
;-------------------------------------------------------
PROC display_foo; input dx is offset 
	mov ah,9
	int 21h
	xor dx, dx
	ret
ENDP display_foo 
;-----------------------------------------------------
PROC input_foo                 ; input string  out ax
    mov ah, 0ah                   ; ah <- 0ah input 
    mov dx, offset string     ; dx <- offset string 
    int 21h                          ; call  0ah function DOS int 21h

	xor ax, ax
	mov bx, offset string
	mov ax, [bx+1]
	shr ax, 8
	ret
ENDP input_foo

END Start
 

TITLE ЛР_7_1 
;------------------------------------------------------------------------------
;ЛР  № 7-1 АК
;------------------------------------------------------------------------------
; 
; Завдання:             
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:    1          
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
IDEAL
MODEL   small
STACK   256
DATASEG

      string  db      254     ;змінна для строки - string,
      str_len db      0       ;
      db 254 dup ('*')        ; Буфер заповнюється '*' для ;кращого налаштування
;----- Змінні для виводу системних команд        
system_message_1   DB "Input command and press enter\  "  ,'$'
system_message_2   DB "Program end"       ,'$'                             
;----- Змінні для виводу команд під час управління програмою 
display_message_0  DB "------------programm for lab 3 is running !!!--------", 13, 10, '$'
display_message_1  DB "c - for count",   13, 10,  '$'
display_message_2  DB "b - for beep",    13, 10,  '$'
display_message_3  DB "q - for exit",    13, 10,  '$' 
display_message_4  DB "----------programm for lab is END !!! --------------", 13, 10,  '$'
display_message_5  DB "Press any key for beep --------------", 13, 10,  '$'
;--- Змінні що використовувалися під час налаштування програми 
message  DB ?
   ;test_message_1  DB "!!! count DISPLAY",      13, 10,  '$' 
   ;test_message_2  DB "!!! beep DISPLAY",       13, 10,  '$'
   ;test_message_3  DB "q - for exit",           13, 10,  '$'
;------Константи  для функції звуку
       NUMBER_CYCLES  EQU   2000
       FREQUENCY      EQU   600
       PORT_B	      EQU   61H
       COMMAND_REG    EQU   43H	     ; Адреса командного регістру
       CHANNEL_2      EQU   42H	     ; Адреса каналу 2
       simvol  db ?

  CODESEG
   Start:
     mov ax, @data            ;
     mov ds, ax
Main_: ; 
    ;----------------------------------------------
    call display_foo_main
    ;-----------------------------------------------
    mov ah, 0ah              ; ah <- 0ah 
    mov dx, offset string    ; пе
    int 21h                  
    xor ax, ax
    mov bx, offset string        ;пе
                              
    mov ax, [bx+1]             
                               

    shr ax, 8                   
                              ;
    cmp ax, 063h ; 
    je Count                      ; 
    cmp ax, 062h ; 
    je Beep
    cmp ax, 071h ; 
    je  Exit
    jmp Main_
;---------------------------------------------------------
Count:
    
jmp Main_
;---------------------------------------------------------
Beep:
    ; any foo for sound             ; виклик функції звуку
   mov dx, offset display_message_5  
   call display_foo
   call  SNDF1
   jmp Main_
;---------------------------------------------------------
; Стандартний вихід з програми
   Exit:
   mov dx, offset display_message_4  
   call display_foo
   mov ah,04Ch          ; 
   int 21h              ; 
;--------------------------------------------
; Відображення Інтерфейсу користувача 
; На вхід:	---
;		
; На вихід: ---
;---------------------------------------------
PROC display_foo_main
     mov ah, 0                 
     mov al, 3
     int 10h
     mov dx, offset display_message_0
     call display_foo
     mov dx, offset display_message_1
     call display_foo
     mov dx, offset display_message_2
     call display_foo
     mov dx, offset display_message_3
     call display_foo
     mov dx, offset system_message_1
     call display_foo
  ret
ENDP display_foo_main

;--------------------------------------------
; Відображення рядка 
; На вхід:	dx, offset system_message_1
;		
; На вихід: ---
;---------------------------------------------
PROC display_foo
     mov ah,9
     int 21h
     xor dx, dx
  ret
ENDP display_foo 

;------------------------------------------------
; Генерація звуку на сист динамік 
; На вхід:	---
;		
; На вихід: ---
;---------------------------------------------
PROC  SNDF1
       
int 16h                ; Зберігає отримане значення з клавіатури  в змінній 
mov [simvol],al        ; simvol
cmp [simvol],'e'       ; Перевірка на відповідність і встановлення прапору ознаки 0
jz Exit                ; 
                       ; Перехід на Exit: у випадку відповідності 
    
;Встановлення частоти 440 гц

;--- дозвіл каналу 2 встановлення порту  В мікросхеми 8255
in   AL,PORT_B     ;Читання
or   AL,3	         ;Встановлення двох молодших бітів
out  PORT_B,AL     ;пересилка байта в порт B мікросхеми 8255

;--- встановлення регістрів порту вводу-виводу
mov  AL,10110110B	 ;біти для каналу 2
out  COMMAND_REG,AL  ;байт в порт командний регістр

;--- встановлення лічильника 
mov  AX,2705	     ;лічильник = 1190000/440
out  CHANNEL_2,AL    ;відправка AL
mov  AL,AH	     ;відправка старшого байту в AL
out  CHANNEL_2,AL    ;відправка старшого байту 

;--- виклик преривання з клавіатури для зупинки
mov  AH,8	     ;¬номер функції преривання 8
int  21H	     ;виклик преривання

;--- виключення звуку 
in   AL,PORT_B     ;отримуємо байт з порту В
and  AL,11111100B  ;скидання двох молодших бітів
out  PORT_B,AL     ;пересилка байтів в зворотному напрямку
ret
ENDP SNDF1

END Start

Перелік запитань для підготовки до лабораторної роботи

1. Опишіть типи, призначення регістрів і організацію пам’яті мікропроцесорів архітектури ІА-32. 
2. Перерахуйте регістри загального призначення мікропроцесорів архітектури ІА-32. Для чого призначені регістри, які їх особливості? Розкрийте поняття розрядності регістрів.
3. Перерахуйте сегментні регістри архітектури  ІА-32. Розкрийте поняття розрядності регістрів. Що зберігається у цих регістрах під час виконання програми.
4. Перерахуйте системні регістри мікропроцесорів архітектури ІА-32. Для чого призначені регістри, які їх особливості? 
5.	Як здійснюється адресація у  мікропроцесорах архітектури ІА-32 у реальному режимі і захищеному режимі, навіщо розроблений цей механізм?











TITLE ЛР_8 
;------------------------------------------------------------------------------
;ЛР  № 8
;------------------------------------------------------------------------------
; 
; Завдання:              Основи розробки і налагодження
; ВУЗ:                  КПІ ім. Ігоря Сікорського
; Факультет:    ФІОТ
; Курс:                1
; Група:       __ __ __
;------------------------------------------------------------------------------
; Автор:        __ __ __
; Дата:         __/__/__
;---------------------------------
			TITLE      STRMENU (EXE) 
           .MODEL SMALL
           .STACK 64
           .DATA
;-------------------------------------------------------------------------
TOPROW     EQU    08          ; Верхній рядок меню
BOTROW     EQU    15          ; Нижній рядок меню
LEFCOL     EQU    26          	; Лівий стовпчик меню
ATTRIB     DB     ?           ; Атрибути екрану
ROW        DB     00          ; Рядок екрану
SHADOW     DB     19 DUP(0DBH);
MENU       DB     0C9H, 17 DUP(0CDH), 0BBH
           DB     0BAH, ' Add records     ',0BAH
           DB     0BAH, ' Delete records  ',0BAH
           DB     0BAH, ' Enter orders    ',0BAH
           DB     0BAH, ' Print report    ',0BAH
           DB     0BAH, ' Update accounts ',0BAH
           DB     0BAH, ' View records    ',0BAH
           DB     0C8H, 17 DUP(0CDH), 0BCH
PROMPT     DB     'To select an item, use <Up/Down Arrow>'
           DB     ' and press <Enter>.'
           DB     13, 10, 'Press <Esc> to exit.'
.386  ;-------------------------------------------------------------------
           .CODE
A10MAIN    PROC   FAR
           MOV    AX,@data           
           MOV    DS,AX              
           MOV    ES,AX              
           CALL   Q10CLEAR          ; Очищення екрана
           MOV    ROW,BOTROW+4       
A20:
           CALL   B10MENU            ; Виведення меню
           MOV    ROW,TOPROW+1       ; Вибір верхнього пункту меню 
                                    			 ;   у якості початкового значення
           MOV    ATTRIB,16H         ; Переключення зображення в інв.
           CALL   D10DISPLY          ; Відображення
           CALL   C10INPUT           ; Вибір з меню
           JMP    A20                ;
A10MAIN    ENDP
;-------------------------------------------------------------------------
;    Виведення рамки, меню і запрошення…
;-------------------------------------------------------------------------
B10MENU    PROC   NEAR
           PUSHA                     ;
          MOV    AX,1301H           ;
           MOV    BX,0060H           ;
           LEA    BP,SHADOW          ;
           MOV    CX,19              ;
           MOV    DH,TOPROW+1        ;
           MOV    DL,LEFCOL+1        ;
B20:       INT    10H
     ;;;;;
           INC    DH                 ; Наступний рядок
           CMP    DH,BOTROW+2        ;
           JNE    B20                ;   
           MOV    ATTRIB,71H         ;
           MOV    AX,1300H           ;
           MOVZX  BX,ATTRIB          ;
           LEA    BP,MENU            ;
           MOV    CX,19              
           MOV    DH,TOPROW          ; Рядок 
           MOV    DL,LEFCOL          ; Стовпчик
B30:
           INT    10H
           ADD    BP,19              ;
           INC    DH                 ;
           CMP    DH,BOTROW+1        ;
           JNE    B30                ;   
           MOV    AX,1301H           ;
           MOVZX  BX,ATTRIB          ;
           LEA    BP,PROMPT          ;
           MOV    CX,79              ;
           MOV    DH,BOTROW+4        ;
           MOV    DL,00              ;   
           INT    10H
           POPA                      ;‚
           RET
B10MENU    ENDP
;-------------------------------------------------------------------------
;  Натискання клавіш, управління через клавиші й ENTER
;  для вибору пункту меню і клавіші ESC для виходу
;-------------------------------------------------------------------------
C10INPUT   PROC    NEAR
           PUSHA                     ;
C20:       MOV     AH,10H            ; Запитати один символ з кл.
           INT     16H               ;   
           CMP     AH,50H            ; Стрілка донизу
           JE      C30
           CMP     AH,48H            ; Стрілка догори?
           JE      C40
           CMP     AL,0DH            ; Натистнено  ENTER?
           JE      C90
           CMP     AL,1BH            ; Натиснено  ESCAPE?
           JE      C80               ;   Вихід
           JMP     C20               ; Жодну не натиснено, повторення
C30:
           MOV     ATTRIB,71H        ; Колір символів
           CALL    D10DISPLY         ;
           INC     ROW               ;
           CMP     ROW,BOTROW-1      ;
           JBE     C50               ;   
           MOV     ROW,TOPROW+1      ;   
           JMP     C50
C40:
           MOV     ATTRIB,71H        ; Колір символів і екрана
           CALL    D10DISPLY         ;
                                     ;   
           DEC     ROW
           CMP     ROW,TOPROW+1      ;
           JAE     C50               ;   
           MOV     ROW,BOTROW-1      ;   
C50:
           MOV     ATTRIB,17H        ; Колір символів
           CALL    D10DISPLY         ;
           JMP     C20
C80:
           MOV     AX,4C00H
           INT     21H
C90:
           POPA                      
           RET
C10INPUT    ENDP
;-------------------------------------------------------------------------
;  Забарвлення виділеного рядка
;-------------------------------------------------------------------------
D10DISPLY  PROC    NEAR
           PUSHA                     
           MOVZX   AX,ROW            
           SUB     AX,TOPROW
           IMUL    AX,19             
           LEA     SI,MENU+1         
           ADD     SI,AX
           MOV     AX,1300H          
           MOVZX   BX,ATTRIB         
           MOV     BP,SI             
           MOV     CX,17             
           MOV     DH,ROW            
           MOV     DL,LEFCOL+1       
           INT     10H
           POPA                      
           RET
D10DISPLY  ENDP
;------------------------------------------------------------------------
;    Очищення екрана
;------------------------------------------------------------------------
Q10CLEAR   PROC    NEAR
           PUSHA                     
           MOV     AX,0600H
           MOV     BH,61H            
           MOV     CX,00             
           MOV     DX,184FH
           INT     10H
           POPA                      
           RET
Q10CLEAR   ENDP
           END     A10MAIN

 Перелік запитань для підготовки до лабораторної роботи
1. Опишіть типи, призначення регістрів і організацію пам’яті мікропроцесорів архітектури AMD64 (Intel® 64). 
2. Перерахуйте регістри загального призначення мікропроцесорів архітектури AMD64 (Intel® 64). Для чого призначені регістри, які їх особливості. 
3. Перерахуйте сегментні регістри архітектури  AMD64 (Intel® 64).  Що зберігається у цих регістрах в архітектурі  AMD64 (Intel® 64).
4. Перерахуйте системні регістри мікропроцесорів архітектури AMD64 (Intel® 64).  Для чого призначені регістри, які їх особливості? 
5. Як здійснюється адресація у  мікропроцесорах архітектури AMD64 (Intel® 64) у реальному режимі і захищеному режимі, навіщо розроблений цей механізм?
6. Опишіть типи, призначення регістрів і організацію пам’яті мікропроцесорів архітектури ARM64.





























СПИСОК ЛІТЕРАТУРИ

Основна література
1. Advanced Micro Devices, Inc. AMD64 Architecture Programmer’s Manual Volume 1: Application Programming. Publication No. 24592. Revision Date 3.22. December 2017 [Electron resource]. – Access link: https://archive.org/details/advancedmicrodevices_24592_3.22/mode/2up.
2. Intel® Corporation. Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4. Submitted: May 01, 2018 Last updated: May 27, 2020 [Electron resource]. – Access link: https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html.
3. Таненбаум Э. Архитектура компьютера / Э. Таненбаум, Т. Остин. – Изд. 6-е. – СПб. : Питер, 2013. – 816 с.: ил.
4. Рудаков П. И. Программируем на языке ассемблера IBM РС / П. И. Рудаков, 
К. Г. Финогенов. – Изд. 2-е. – ОбНШиск: Изд-во «Питер», 1997. – 584 с.
5. 8th and 9th Generation Intel® Core Prosessor families and Intel® Xeon E Prosessor familie. Datasheet, vol2 of 2. May 2020. Rev® 003.




Допоміжна література 
1. Програмування 3. Системне програмування [Електронний ресурс] : метод. рекомендації до викон. лаб. робіт для студ. кафедри Автоматики та управління у техн. системах заочної форми навчання / НТУУ «КПІ» ; Уклад. П. Ю. Катін. – 2-ге вид., випр. і доп. – Електронні текстові дані (1 файл: 432 Кбайт). – Київ : НТУУ «КПІ», 2015. – 73 с. – Назва з екрана. 
2. Тарарака В. Д. Т19 Архітектура комп’ютерних систем : навч. посіб. / В. Д. Тарарака. – Житомир : ЖДТУ, 2018. – 383 с. 
3. Сучасні напрямки комп’ютерної та мікропроцесорної техніки. Розділ 1. Основні тенденції розвитку комп’ютерної і мікропроцесорної техніки. Розділ 2 Характеристики ARM і Cortex процесорів: конспект лекцій [Електронний ресурс]: для студ. спец. 171 Електроніка, спеціалізації «Електронні компоненти та системи» / Уклад. : Т. О. Терещенко, Ю. С. Ямненко; КПІ ім. Ігоря Сікорського. – Електронні текстові данні (1 файл: 5,248 Мбайт). – Київ: КПІ ім. Ігоря Сікорського, 2020. – 68 с.   
4. INTEL 80386 PROGRAMMER’S REFERENCE MANUAL / INTEL CORPORATION. 1986. – 421 с. [Electron resource]. – Access link: https://css.csail.mit.edu/6.858/2014/readings/i386.pdf.
5. Абель П. Язык программирования для IBM PC [пер. с англ.] / П. Абель. – Киев : Век+., М. : ЭНТРОП, Киев : НТИ, 2003. – 736 с.

Додаток 1. Опис механізмів адресації 
%TITLE "Пpиклад адpесацiй"
    ideal               
    model   small
    stack   256

    dataseg

; Опис структури

struc  employee ;struc - директива(псевдокоманда) TASM для визначення
                ;структури даних;employee(службовець) - назва(iм'я) структури
  dept    db  1 ;поле(елемент) структури - dept(департамент), довжиною в 1 байт
                ;i початково встановленим значенням = 1
  div_    db  2 ;поле(елемент) структури - div(вiддiл), довжиною в 1 байт
                ;i початково встановленим значенням = 2
  vac     db  3 ;поле(елемент) структури - vac(вакансiя), довжиною в 1 байт
                ;i початково встановленим значенням = 3
  array   dw  7 dup (0eeeeh);поле структури - array(масив), яке визначає
                            ;масив з 7 змiнних, довжиною в слово
                            ;i початковим значенням = 0EEEEh
  rate    dw  0ffffh ;поле(елемент) структури - rate(ставка), довжиною в 2 байта
                     ;i початково встановленим значенням = 0FFFFh
  age     db  21     ;поле(елемент) структури - age(вiк), довжиною в 1 байт
                     ;i початково встановленим значенням = 21
  status  db  6      ;поле(елемент) структури - status(статус), довжиною в 1 байт
                     ;i початково встановленим значенням = 6
ends   employee    ;ends - директива(псевдокоманда) TASM для визначення кiнця
                   ;структури даних;employee(службовець) - назва(iм'я) структури

  array2Da db  0,1,2,3    ;двомiрний масив array2Da, що складається з трьох рядкiв
           db  4,5,6,7    ;i чотирьох стовбчикiв
           db  8,9,10,11

  Maxim  employee <>;оголошення структури employee (Maxim - мiтка)
                    ;<> - вказує TASM на те, що значення полей (елементiв)
                    ;структури рiвнi тим, котрi були початково встановленi при
                    ;описi структури
  Alex  employee <2,4,5,,5555h,22,5>;оголошення структури employee
                               ;(Alex - мiтка)
                               ;<2,4,5,,5555h,22,5> - вказує TASM на те, що
                               ;значення полiв структури рiвнi:
            ;dept = 2
            ;div = 4
            ;vac = 5
            ;array = значенню, яке було встановлено при описi структури
            ;rate =  5555h
            ;age =  22
            ;status = 5

exCode   db  0          ;iм'я змінної exCode резервується для запису коду
                        ;помилки, якщо виникне помилка i виконання програми
                        ;буде перервано.В цьому разi код помилки записується 
                        ;в комiрку exCode i виконується команда JMP Exit.
dataByte db  99         ;iнiцiалiзована змiнна, довжиною в один байт
                        ;i значенням 99D.
dataWord dw  0FACEh     ;iнiцiалiзована змiнна, довжиною в два байти
                        ;(слово) и значенням FACEh.
array1   db  'a','b','c','d','e','f' ;одномiрний масив з шести символьних
                                     ;констант a, b, c, d, e, f.
array2Db db  1,0,0,0    ;двомiрний масив array2Db, що складається з трьох рядкiв
         db  1,1,0,0    ;i чотирьох стовбчикiв
         db  1,1,1,1

copyright db  'Copyright (c) 1998-2000 Max  Natali IA-82',0 ; рядкова
                         ;змiнна copyright (ASCIIZ - рядок)
cpy_len = $ - copyright  ;макровизначення (константа) cpy_len, що визначає
                         ;довжину рядкової змiнної copyright, де
                         ;$ - адреса наступної команди, а
                         ;copyright - адрес рядкової змiнної
string    db  'left ' ;рядок (масив) з п'яти символьних констант:l,e,f,t, .
str_len = $ - string  ;макровизначення (константа) str_len, що визначає
                      ;довжину рядкової змiнної string, де
                      ;$ - адреса наступної комiрки dataseg, а
                      ;string - адреса рядка (масива)

      codeseg

codeByte DB 11     ;iнiцiалiзована змiнна codeByte, довжиною в 1 байт
                   ;i початково встановленим значенням = 11
codeWord DW 0DECFh ;iнiцiалiзована змiнна codeWord, довжиною в слово
                   ;и початково встановленим значенням = DECFh

Start:             ;точка входу в програму.Визначається в кiнцi програми 
                   ;рядком END START.

        mov     ax, @data  ;ax<-@data
; @data- 16-и розрядна                            ;\
; константа(зарезервоване слово) - логiчна адреса ; \
; сегмента DS                                     ;  > iнiцiалiзацiя ds i es
        mov     ds, ax     ;ds<-ax                ; /
        mov     es, ax     ;es<-ax                ;/

; Безпосередня адpесацiя

    mov ah, 1             ;Пересилка байта=1 в ah (ah<-1)
    mov bx, 0FFh          ;Пересилка слова=0FFh в bx (bx<-0FFh)

    add al, 85h           ; а)  al<-al+85h
    add ax, 7a85h         ; б)  ax<-ax+7a85h

    add dl, 0b6h          ;в)  dl<-dl+0b6h
    add dx, 2fb6h         ; г)  dx<-dx+2fb6h

    add dx, 0ffb6h        ;pис.20 д)  dx<-dx+0ffb6h
            ;Якщо значення усiх розрядiв СБ БО спiвпадають зi старшим бiтом
            ;МБ БО, то компiлятор оптимiзує машиний код, включаючи в
            ;нього тiльки МБ БО, який при виконаннi команди розширюється
            ;до 2-х байт значенням старшого знакового бiта МБ БО (див. лiстинг)

   mov bx, offset dataWord ;Завантаження адpеси(змiщення в сегментi DS) змiнної
                           ;dataWord в bx
   mov si, offset dataByte ;Завантаження адpеси(змiщення в сегментi DS) змiнної
                           ;dataByte в si

; Hеявна адpесацiя

    xchg    ax, bx       ;Обмiн мiж ax i bx (ax <-> bx)
                         ;Неявно адресується регiстр ax

; Пpяма адpесацiя

    mov al, [dataByte]     ; а)  al<-M(DSx16+offset dataByte)
    mov ax, [dataWord]   ; б)  al<-M(DSx16+offset dataWord)
                                    ;ah<-M(DSx16+offset dataWord+1)
    mov bl, [dataByte]              ;bl<-M(DSx16+offset dataByte)

    mov [dataWord], dx   ; в) ; M(DSx16+offset dataWord)<-dl
                                    ; M(DSx16+offset dataWord+1)<-dh
    inc [dataByte]    ;M(DSx16+offset dataByte)<-M(DSx16+offset dataByte)+1
    ror [word dataWord],1  ;циклiчний зсув вправо на один розряд
                           ;двобайтної змiнної dataWord
    jmp far very_far_label ; г) команда дальнього безпосереднього переходу
                           ;на мiтку very_far_label, яка знаходиться в тому ж
                           ;самому сегментi та є ближньою, тому
                           ;при асемблеруваннi (див. листинг)
                           ;виникає оптимiзацiя даної команди, тобто
                           ;замiсть КОП 0eah(код дальнього переходу),
                           ;tasm пiдставить 0ebh - машинний
                           ;код команди ближнього безпосереднього переходу, а
                           ;04h=disp8 - рiзниця мiж адресою мiтки (0041h)
                           ;й адресою наступної за jmp, команди NOP (003Dh)

very_far_proc:
    retf                   ;команда повернення з дальньої пiдпрограми

very_far_label:
    call far very_far_proc ;команда виклику дальньої пiдпрограми з мiткою
                           ;very_far_proc.
                           ;компiлятор оптимiзує цю команду и замiнює 
                           ;її двома командами: кодом команди ближньої
                           ;пiдпрограми (E8h),FFFBh=disp - рiзниця мiж
                           ;адресою мiтки (0040h) и адресою наступної команди
                           ;(0045h), що дорiвнює (-5)
                           ;перед кодом E8h компiлятор помiщає код команди
                           ;PUSH CS (0Eh), щоб зберегти значення регiстра CS
                           ;у стеку.(див. лiстинг програми)

; Регистpова адpесацiя

    mov cx, ax             ;пересилка слова з ax в cx
    mov dx, ds             ;пересилка слова з ds в dx

    inc bx                 ;а) bx<-bx+1
    mov dh, ch             ; б) dh<-ch
    mov ch, dh             ; в) ch<-ds

    mov si, bp             ;г) si<-bp
    mov bp, si             ; д) bp<-si

    mov si, ds             ;е) si<-ds
    mov ds, si             ; ж) ds<-si

; Непряма адpесацiя
                                                  
    mov ax, [di]              ;al<-M(DSx16+di)
                              ;ah<-M(DSx16+di+1)
    or  al, [bp]              ;al<-al v M(SSx16+bp)
    mov cl, [bx]              ; б) cl<-M(DSx16+bx)
    mov [si], cl              ; в) M(SSx16+si)<-cl
    mov ax, offset jmp_label  ;ax<-offset jmp_label                
    jmp ax                 ;г)команда ближнього безпосереднього переходу 
                           ;на адресу, що зберiгається в регiстрi 
                           ;ax (offset jmp_label)

    xchg        ax, ax     ;ax<->ax         \ однаковий КОП (див. лiстинг)
    nop                    ;пуста операцiя  /

jmp_label:

    mov ax, [bx]           ;пересилка слова в ax з сегмента даних зi змiщенням,
                           ;що знаходиться в bx

; Базова адpесацiя

    mov     ah, [bp + 77h]        ;б) ah<-M(SSx16+BP+0077h), де 
                                  ;BP=var - база, disp8=77h=const - iндекс 
    mov     ah, [bx + 0fefch]     ; в) ah<-M(DSx16+BX+0FEFCh), де 
                                  ;BX=var - база, disp16=0FEFCh=const - iндекс

    mov     bx, offset Maxim      ;г) bx<-адpеса стpуктуpи employee 
                                  ;з мiткою Maxim
    mov     ax, [bx + 7*2 + 3]    ;ax<-[Maxim.rate]
                                  ;пересилка в ax поля (елемента) rate
                                  ;стpуктуpи employee з мiткою Maxim
    mov     bx, offset Alex       ; г) bx<-адpес стpуктуpи employee 
                                  ;з мiткою Alex
    mov     ax, [bx + 7*2 + 3]    ;ax<-[Alex.rate]
                                  ;пересилка в ax поля (елемента) rate
                                  ;стpуктуpи employee з мiткою Alex
    
   mov     [byte bx + 2],0DDh     ;[Alex.vac] <- 0DDh
                                  ;Завантаження в поле (елемент) vac  
                                  ;стpуктуpи employee с мiткою Alex 
                                  ;константи байта 0DDh

; iндексна адpесацiя

    mov     si, 2                 ; в) si <- 2
    mov     di, 5                 ;di <- 5
    mov     [array1+si],16        ;array1(2) <- 16 
                                  ;M(DSx16+offset array1+si)<-16, де 
                                  ;offset array1=disp16=003A=const - база 
                                  ;масива, si=var - iндекс, що адресує елемент
                                  ;масива (в даному прикладi адресується другий 
                                  ;елемент (si=2) починаючи з нульового)
    mov     [array1+di],0EDh      ;array1(5) <- 0EDh
                                  ;M(DSx16+offset array1+di)<-16, де адресується
                                  ;п'ятий елемент масива array1 (di=5)
    mov     ah,[array1+di]        ;ah <- array1(5), пересилка п'ятого елемента 
                                  ;масива array1 в регiстр ah

; Базово-iндексна адpесацiя

    mov     bx, 1                  ; пересилка в регiстр bx номера 
                                   ;стовбчика (№ стовбчика=1) двомiрного масива
                                   ;array2Da (номери стовбчикiв змiнюються 
                                   ;вiд 0 до 3) (BX - база)
    mov     di, 2*4                ;пересилка в регiстр di добутку 
                                   ;номера рядка (№ рядка=2) на число 
                                   ;елементiв в рядку (кiлькiсть елементiв=4)
                                   ;двомiрного масива 2Da (DI - iндекс)
    mov     al, [di+bx]            ;al<-array2Da[2][1] (пересилка в регiстр 
                                   ;al значення елемента масива array2Da, 
                                   ;що лежить на перехрестi другого рядка 
                                   ;й першого стовбчика); масив array2Da 
                                   ;Оголошений на початку сегмента даних i
                                   ;має нульове змiщення
    dec     bx                     ;bx<-bx-1
    mov     al, [di+bx]            ;al<-array2Da[2][0] (пересилка в регiстр
                                   ;al значення елемента двомiрного масива 
                                   ;array2Da, що лежить на перехрестi другого
                                   ;рядка й нульового стовбчика)
        
; Базово-iндексна адpесацiя со змiщенням

    mov     bx, offset Maxim    ; bx<-offset Maxim (завантаження в bx 
                                ;адреси структури employee з мiткою Maxim)
    mov     si, 3*2             ;завантаження в si iндекса, рiвного 3*2
    mov     dx, [bx+3+si]       ;пересилка в регiстр dx третього елемента
                                ;(si=3*2 т.к. елемент масива - слово)
                                ;масива array структури employee з
                                ;мiткою Maxim
    mov     bx, offset Alex     ;bx<-offset Alex (загрузка в bx адреси
                                ;структури employee з мiткою Alex
    mov     si, 5               ;загрузка в si iндекса, рiвного 5
    mov     bl, [bx+3+si]       ;пересилка в регiстр bl старшого байта
                                ;другого елемента
                                ;(si=5) масива array структури employee
                                ;з мiткою Alex
    mov     bx, 3               ;пересилка в регiстр bx номера стовбчика 
                                ;(№ стовбчика=3) двомiрного масива array2Db
    mov     di, 2*4             ;пересилка в регiстр di добутку номера 
                                ;рядку (№рядку=2) на кiлькiсть елементiв в 
                                ;рядку (кiлькiсть елементiв = 4) двомiрного 
                                ;масива array2Db
    mov     ch, [offset array2Db+di+bx] ;ch<-array2Db[2][3] пересилка в регiстр
                                ;ch значення елемента двомiрного масива
                                ;array2Db, що лежить на перехрестi другого рядка
                                ;й третього стовбчика

; Стекова адpесацiя

    push    ax                  ;рис.  M(SSx16+SPпоч-1)<-ah
                                ;        M(SSx16+SPпоч-2)<-al 
                                ;        SP<-SPпоч-2    
    push    bx                  ;        M(SSx16+SPпоч-1)<-bh
                                ;        M(SSx16+SPпоч-2)<-bl 
                                ;        SP<-SPпоч-2    

    pop     ax                  ;        al<-M(SSx16+SPпоч)
                                ;        ah<-M(SSx16+SPпоч+1) 
                                ;        SP<-SPпоч+2    
    pop     bx                  ;        bl<-M(SSx16+SPпоч)
                                ;        bh<-M(SSx16+SPпоч+1) 
                                ;        SP<-SPпоч+2    



back_jump:
    jmp     short forvard_jump  ; безумовний короткий перехiд на мiтку
                                ;forvard_jump, компiлятор (див. лiстинг) 
                                ;формує два байти: 1-й - КОП команди (EBh),
                                ;2-й - disp8=адреса мiтки-адреса наступної 
                                ;команди=00C2h-00C0h=0002h (2D)
    jmp     back_jump           ;безумовний перехiд на мiтку back_jump
                                ;компiлятор (див. лiстинг) формує
                                ;два байти: 1-й - КОП команди (EBh)
                                ;2-й - disp8=адреса мiтки-адреса наступної 
                                ;команди=00BEh-00C2h=FCh (-4D)
forvard_jump:

; адpесацiя стpок даних
                                                                 
    cld                          ; DF<-0 - обнулiння прапорця напрямку 
                                 ;обробки рядкiв
    mov cx, str_len              ;завантаження в регiстр cx константи str_len,
                                 ;що визначає довжину рядка string 
                                 ;(str_len=5D див. лiстинг)
    mov di, offset copyright+4   ;завантаження в регiстр di адреси 4-го елемента
                                 ;ASCII рядка "copyright"
    mov si, offset string        ;завантаження в регiстр si адреси початку
                                 ;нульового елемента ASCII рядка string
    rep movsb                    ;пересилка елементiв рядка string на мiсце
                                 ;п'яти елементiв рядка copyright, починаючи з 
                                 ;4-го елемента (замiнює слово copyright на
                                 ;слово copyleft) 

; Пересилка рядка copyright в вiдеобуфер

    mov     ax, 0b800h           ;Сегментна адреса вiдеобуфера пересилається в
                                 ;регiстр ax
    mov     es, ax               ;es<-ax (ax=сегментнiй адресi вiдеобуфера) 
    mov     ah, 1eh              ;завантаження в регiстр ah атрибута елементiв
                                 ;рядка (жовтий на синьому)
    mov     si, offset copyright ;завантаження в регiстр si адреси початку рядка
                                 ;copyright
    mov     di, 80*2*1           ;Змiщення в вiдеобуферi в байтах (80 символiв
                                 ;в рядку по 2 байта: МБ - код символа,
                                 ;СБ - код його атрибута). В даному випадку - це
                                 ;1-ий рядок, 0-ий стовбчик
    mov     cx, cpy_len          ;завантаження в регiстр cx константи cpy_len, 
                                 ;що визначає довжину рядка copyright
                                 ;(cpy_len=2Eh=46D, див. лiстинг)
    cld                          ;DF<-0 (обнулiння прапорця напрямку обробки 
                                 ;рядкiв)
                                 ;використанi нижче команди роботи з рядками
                                 ;будуть iнкрементувати регiстри si й di
@@stor:
    lodsb                        ;al<-M(DSx16+si)
    stosw                        ;M(ESx16+di)<-al
                                 ;M(ESx16+di+1)<-ah
    loop    @@stor               ;cx<-cx-1, якщо cx<>0, то перехiд на мiтку
                                 ;@@stor, компiлятор (див. лiстинг) формує
                                 ;два байта: 1-й - КОП команди (E2h)
                                 ;2-й - disp8=адреса мiтки-адреса наступної 
                                 ;команди=00DFh-00E3h=FCh (-4D)

; Адpесацiя поpтiв вводу виводу

    in      al, 20               ; введення байта в акумулятор al з порту
                                 ;з адресою 20D=14h
;Команди, що використовують адресацiю портiв введення-виведення,
;використовуються в програмi управлiння свiтлодиодами клавiатури (inout.asm)

;Пеpеназначення сегментних pегiстpiв

    mov     bl, [cs:codeByte]   ;bl<-M(CSx16+offset codeByte)\ сегмент DS
                                ;                         
    mov     [cs:codeByte], bh   ;M(CSx16+offset codeByte)<-bh/ на сегмент CS

Exit:                           ;Стандаpтний вихiд в DOS з виконуваної
                                ;пpогpами
        mov     ah,04Ch         ;ah <- 04Ch 
                                ;4Ch - функцiя DOS (завершення пiдпроцеса 
                                ;з поверненням упpавлiння програмi command.com)
        mov     al,[exCode]     ;al <- M(DS*16+offset exCode)
                                ;запис в al кода помилки
        int     21h             ;переривання DOS, що викликає функцiю DOS,
                                ;яка визначається кодом в регiстрi ah  
END Start                       ;кiнець програми Start

 



