; -----------------------------------------
; ЛР №5
; -----------------------------------------
; Архітектура комп'ютера
; Завдання: 
; ВУЗ: КНУУ "КПІ"
; Факультет: ФІОТ
; Курс: 1
; Група: ІТ-03
; -----------------------------------------
; Автори:	Букрєєв М.С.
;			Король К.В.
;			Федяй Б.В.
; Дата: 12/04/2021
; -----------------------------------------

;					І. Заголовок програми
IDEAL
MODEL small
STACK 256
;					ІІ. Макроси
MACRO M_init		; Макрос для ініціалізації. Його початок
	mov ax, @data	; @data ідентифікатор, що створюються директивою MODEL
	mov ds, ax		; Завантаження початку сегменту даних в регістр DS
	mov es, ax		; Завантаження початку сегменту даних в регістр ES
	ENDM M_init		; Кінець макросу
;					ІІІ. Початок сегменту даних
task_offset equ 16+1
bdates_length equ 8*3
arrray_length equ 16*16-1
DATASEG
array db 15, 169, 72, 20, 140, 146, 43, 8, 136, 111, 152, 171, 95, 167, 13, 114
	  db 189, 156, 158, 83, 173, 93, 153, 212, 185, 147, 172, 111, 130, 201, 83, 154
	  db 66, 222, 95, 134, 193, 23, 83, 75, 91, 183, 232, 37, 122, 172, 245, 65
	  db 172, 32, 195, 34, 80, 66, 254, 155, 222, 203, 112, 183, 15, 176, 29, 54
	  db 250, 118, 245, 90, 234, 97, 102, 66, 13, 108, 212, 34, 249, 68, 10, 96
	  db 62, 61, 242, 31, 57, 80, 73, 188, 178, 2, 201, 124, 54, 249, 134, 1
	  db 134, 39, 209, 215, 245, 3, 182, 71, 253, 239, 79, 99, 73, 56, 150, 180
	  db 174, 237, 180, 162, 214, 69, 236, 252, 1, 199, 7, 21, 49, 141, 37, 51
	  db 151, 58, 10, 151, 33, 142, 15, 113, 252, 66, 120, 223, 248, 193, 145, 175
	  db 75, 131, 211, 95, 91, 216, 254, 175, 163, 228, 179, 140, 166, 198, 230, 192
	  db 208, 87, 57, 209, 253, 180, 59, 137, 204, 48, 4, 45, 96, 149, 0, 46
	  db 136, 236, 75, 212, 17, 250, 166, 199, 36, 189, 192, 98, 173, 231, 11, 233
	  db 99, 178, 152, 27, 23, 232, 28, 77, 143, 113, 25, 244, 74, 44, 207, 76
	  db 86, 90, 29, 186, 93, 193, 205, 244, 95, 49, 155, 204, 100, 139, 149, 20
	  db 21, 148, 248, 122, 177, 53, 251, 77, 133, 254, 147, 102, 13, 175, 167, 109
	  db 189, 86, 86, 70, 243, 30, 30, 142, 255, 41, 160, 111, 240, 35, 31, 1
bdates db 30h,32h,30h,39h,32h,30h,30h,32h
	   db 31h,39h,31h,31h,32h,30h,30h,32h
	   db 30h,39h,31h,31h,32h,30h,30h,32h
subsqr_end db task_offset+16*7+8
exCode db 0
;					IV. Початок сегменту коду
CODESEG
Start:
	M_init	; Виклик макросу для ініціалізації
	; -----------------------------------------
	; Запис квадрату 8х8 до масиву
	; -----------------------------------------
	mov bx, offset bdates
	mov di, offset array+task_offset
	; AL - лічильник строки
	mov al, 0
	; CL - лічильник симовлу
	mov cl, 0
	
	LINE_PICKER:
		cmp al, 8					; Перевіряемо, скільки строк ми записали
		je LINE_PICKER_END			; Якщо записали 8 - закінчуємо запис
		
		cmp bx, offset bdates+24	; Перевіряємо, чи вийшли ми за границі значень масиву bdates
		jne SYMBOL_WRITER
		sub bx, 24					; Якщо так, то повертаємось до його початку
		SYMBOL_WRITER:				; Цей цикл відповідає за запис значень із bdates до масиву array
			cmp cl, 8				; Перевіяємо, скільки символів ми вже записали
			je SYMBOL_WRITER_END	; Якщо записали усі - віходимо з циклу
			
			mov dx, [bx]			
			mov [di], dx			; Записуємо значення із масиву bdates до масиву array
									
			inc di
			inc bx
			inc cl
			jmp SYMBOL_WRITER
		SYMBOL_WRITER_END:
		mov cl, 0

		add di, 8
		inc al
		jmp LINE_PICKER
	LINE_PICKER_END:
	; -----------------------------------------
	; Сортування масиву (Selection Sort)
	; -----------------------------------------
	mov si, offset array 		; SI Вказує на перший елемент (після першої ітерації - останній відсортований)
	SORT_START:
		mov bp, si				; Лічильник ітерацій у циклі пошуку
		inc bp
		mov bx, bp				; Адреса першого елементу у циклі пошуку 
		mov di, 0				; Зміщення адреси при пошуку найбільшого елементу
		mov ah, [bx]			; Перший елемент у циклі пошуку (після нього - найменший елемент після операції пошуку)
		
		HIGHEST_FINDER:			; Цикл пошуку найбільшого елементу після елементу за адресою DS:SI
		cmp bp, arrray_length	; Умова виходу із циклу пошуку
		je SWAPPER				; Цикл буде перерваний, якщо ми дійшли до кінця таблиці при пошуку
		
		inc di
		cmp ah, [bx+di]			
		ja ISNT_HIGHEST			; Якщо елемент AH менший за [BX+SI], тоді ми НЕ ПЕРЕСТРИБУЄМО наступні до ISNT_HIGHEST
		add bx, di
		mov ah, [bx]
		mov di, 0
		ISNT_HIGHEST:
		inc bp
		jmp HIGHEST_FINDER
		
		SWAPPER:				; Цикл переміщення найбільшого елементу на його місце
		cmp [si], ah			
		ja NO_SWAP				; Якщо DS:SI більше AH, то ми змінюємо їх місцями (елемент вже стоїть на своєму місці)
		mov al, [si]
		mov [si], ah
		mov [bx], al
		
		NO_SWAP:				; Якщо ні, то стрибаємо сюди
		inc si
		cmp si, arrray_length
		je SORT_END				; Якщо ми пройшли увесь масив (SI = arrray_length), то ми ви
		jmp SORT_START			
	SORT_END:
	; -----------------------------------------
	mov ah, 4ch			; Завантаження числа 01h до регістру AH 
	mov al, [exCode]	; Завантаження значення exCode до регістру AL
	int 21h				; Виклик преривання 21h (AH = 4ch, AL = код виходу - команда виходу із програми)
	end Start