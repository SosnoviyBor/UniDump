; -----------------------------------------
; ЛР №8
; -----------------------------------------
; Архітектура комп'ютера
; Завдання: Псевдо-графічний інтерфейс
; ВУЗ: КНУУ "КПІ"
; Факультет: ФІОТ
; Курс: 1
; Група: ІТ-03
; -----------------------------------------
; Автори:	Букрєєв М.С.
;			Король К.В.
;			Федяй Б.В.
; Дата: 12/05/2021
; -----------------------------------------
IDEAL			; Директива - тип Асемблера tasm 
MODEL small		; Директива - тип моделі пам’яті 
STACK 2048		; Директива - розмір стеку 

; // MARK: Macros
; ==================================== Макроси ====================================
; ---------------------------------------------------------------------------------
; Призначення: ініціалізація програми
; ---------------------------------------------------------------------------------
MACRO M_init		; Макрос для ініціалізації. Його початок
	mov ax, @data	; @data ідентифікатор, що створюються директивою MODEL
	mov ds, ax		; Завантаження початку сегменту даних в регістр DS
	mov es, ax		; Завантаження початку сегменту даних в регістр ES
		mov al,1
	out 42h, al     ;ініціалізація таймера
	ENDM M_init		; Кінець макросу

; ---------------------------------------------------------------------------------
; Призначення: вихід із програми (із кодом 0)
; ---------------------------------------------------------------------------------
MACRO M_exit
	mov ah, 4ch
	mov al, 0
	int 21h
	ENDM M_exit

; ---------------------------------------------------------------------------------
; Призначення: запам'ятовування значень регістрів
; ---------------------------------------------------------------------------------
MACRO M_push_all
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	ENDM M_push_all

; ---------------------------------------------------------------------------------
; Призначення: повернення значень регістрів
; ---------------------------------------------------------------------------------
MACRO M_pop_all
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax
	ENDM M_pop_all

; ---------------------------------------------------------------------------------
; Призначення: 
; ---------------------------------------------------------------------------------
MACRO M_write_results
	mov dh, result_V_offset   ;початок виведення зверху  
	mov dl, 0            ;початок виведення зліва  
	mov ax, 1300h        ;функція відображення символів 
	mov bx, COLOR_output ;колір виводу
	mov cx, output_length  ;кількість символів для відображення
	int 10h              ;виклик переривання BIOS
	ENDM M_write_results

; ================================= Сегмент даних =================================
; // MARK: Dataseg
DATASEG
; ===== Змінні =====
menu db 201d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,187d
     db 186d,' View creators  ',186d
     db 186d,' Do noise       ',186d
     db 186d,' Solve equation ',186d
     db 200d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,188d
help_message 	 db ' Arrows, ESC, Enter. You know it, its the same '
creators_message db ' Team 1 consists of Bukreev, Korol and Fedyay  '
equation_message db ' (-7+3)*2/4+1=                                 '

standby db 13,10
		db "                    ___                                          ___",13,10
		db " __________________/  /                       __________________/  /",13,10
		db "| _    _______    /  /                       | _    _______    /  /",13,10
		db "|(_) .d########b. //)| _____________________ |(_) .d########b. //)|",13,10
		db "|  .d############//  ||        _____        ||  .d############//  |",13,10
		db '| .d######""####//b. ||() ||  [Team1]  || ()|| .d######""####//b. |',13,10
		db "| 9######(  )#_//##P ||()|__|  | = |  |__|()|| 9######(  )#_//##P |",13,10
		db "| 'b######++#/_/##d' ||() ||   | = |   || ()|| 'b######++#/_/##d' |",13,10
		db '|  "9############P"  ||   ||   |___|   ||   ||  "9############P"  |',13,10
		db '|  _"9a#######aP"    ||  _   _____..__   _  ||  _"9a#######aP"    |',13,10
		db '| |_|  `""""""       || (_) |_____||__| (_) || |_|  `""""""       |',13,10
		db "|  ___..___________  ||_____________________||  ___..___________  |",13,10
		db "| |___||___________| |                       | |___||___________| |",13,10
		db "|____________________|                       |____________________|",13,10
		db 13,10,13,10,13,10,13,10,13,10,13,10,13,10,13,10,13,10,13,10,'$'

a1 db -7
a2 db 3
a3 db 2
a4 db 4
a5 db 1

current_option db 1

; ===== Константи =====
output_length equ 47

frequency equ 20
duration equ 1000

equation_length equ 14

; 00h - black
; 10h - blue
; 20h - green
; 30h - light blue
; 40h - red
; 50h - purple
; 60h - brown
; 70h - grey
COLOR_background equ 00h
COLOR_menu equ 70h
COLOR_current_option equ 60h
COLOR_output equ 60h
; H - Horizontal
; V - Vertical
menu_H_length equ 18
menu_V_offset equ 1
menu_H_offset equ 1
menu_last_row equ menu_V_offset + 4
result_V_offset equ 7
option_amount equ 3

; =================================== Сегмент коду ====================================
CODESEG
Start:
	; ===== Код програми =====
	M_init

	call clear_screen  ;Виклик очистки екрану
	call draw_a_menu     ;Виклик выдображення меню
	call highlight_current_option  ;Виклик виведення теперышнього вибраного рядка
	lea bp, [help_message];Виведення помічного тексту
	M_write_results
	call ask_for_input;Виклик зчитування з клавіатури та обробок

	M_exit

	; =================================== Процедури ===================================
	; ---------------------------------------------------------------------------------
	; Призначення: очищення екрану
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC clear_screen
		M_push_all

		mov ax, 0600h   ;функція монотонного залиття екрану
		mov bh, COLOR_background     ;колір бекграунду
		mov cx, 0       ;відступ зліва
		mov dx, 184Fh    ;dh, dl - кількість зафарбованих рядків, колонок
		int 10h         ;переривання BIOS

		M_pop_all
		ret
		ENDP clear_screen


	; ---------------------------------------------------------------------------------
	; Призначення: 
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC draw_a_menu
		M_push_all

		mov dh, menu_V_offset       ;початок виведення зверху  
		mov dl, menu_H_offset      ;початок виведення зліва  
		mov ax, 1300h         ;функція відображення символів 
		mov bx, COLOR_menu    ;колір меню
		mov cx, menu_H_length ;кількість символів для відображення
		xor si,si             ;вибраний рядок

		main_loop_1:
			lea bp, [MENU+si]     ;вибір рядка для відображення
			int 10h               ;виклик переривання BIOS
			inc dh                ;збільшення dh
			add si, menu_H_length ;збільшення si
			cmp dh, menu_last_row+1  ;перевірка на кінець меню
			jne main_loop_1       ;перевірка на кінець меню

		M_pop_all
		ret
		ENDP draw_a_menu

	; ---------------------------------------------------------------------------------
	; Призначення: 
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC highlight_current_option
		M_push_all
		
		call draw_a_menu
		mov dh, [current_option]   ;початок виведення зверху
		add dh, menu_V_offset         ;
		mov dl, menu_H_offset+1      ;початок виведення зліва  
		mov cx, menu_H_length-2 ;кількість символів для відображення
		mov al, menu_H_length    ;/
		mov bl, [current_option]   ;визначення, який пункт буде обрано
		mul bl                  ;
		mov si, ax              ;\
		mov ax, 1300h           ;функція відображення символів 
		mov bx, COLOR_current_option   ;колір вибраного пункту
		lea bp, [menu+si+1]     ;вибір рядка для відображення
		int 10h                 ;виклик переривання BIOS
		
		M_pop_all
		ret
		ENDP highlight_current_option

	; ---------------------------------------------------------------------------------
	; Призначення: 
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC ask_for_input
		M_push_all
		;
		input:
			mov ah, 10h     ;функція зчитування з клавіатури
			int 16h
			cmp ah, 50h     ;стрілка вверх
			je arrow_up
			cmp ah, 48h     ;стрілка вниз
			je arrow_down
			cmp al, 0Dh     ;Enter
			je enter_
			cmp al, 1Bh     ;ESC
			je escape
			jmp input; повторення циклу
			;
		arrow_down:
			mov al, [current_option] ;вибір рядка
			cmp al, 1             ;перевірка на максимум
			je input       ;вихід, якщо максимум
			dec al
			mov [current_option], al ;Зміна теперішнього рядка
			call highlight_current_option      ;Виведення на екран теперішнього рядка
			jmp input

		arrow_up:
			mov al, [current_option] ;вибір рядка
			cmp al, option_amount    ;перевірка на максимум
			je input       ;вихід, якщо максимум
			inc al
			mov [current_option], al ;Зміна теперішнього рядка
			call highlight_current_option      ;Виведення на екран теперішнього рядка
			jmp input

		enter_:
			call procChooser      ;виклик процедури виклику процедур
			jmp input

		escape:               ;Вихід з программи
		M_exit
		M_pop_all
		ret
		ENDP ask_for_input

	; ---------------------------------------------------------------------------------
	; Призначення: вибір потрібної процедури на виконання
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC procChooser
		M_push_all

		mov al, [current_option]   ;Перевірка вибранного рядка
		cmp al, 1
		je item_1
		cmp al, 2
		je item_2
		cmp al, 3
		je item_3

		item_1:             ;Перший пункт меню
		lea bp, [creators_message]
		M_write_results 
		jmp proc_chooser_end

		item_2:             ;Другий пункт меню
		call do_noise
		jmp proc_chooser_end

		item_3:             ;Третій пункт меню
		call calculate
		jmp proc_chooser_end

		proc_chooser_end:

		M_pop_all
		ret
		ENDP procChooser

	; ---------------------------------------------------------------------------------
	; Призначення: програш звуку
	; Вхід:
	; frequency <- частота звуку
	; duration <- тривалість звуку
	; Вихід:
	; Максимально противний звук із колонок. Наслоджуйтесь
	; ---------------------------------------------------------------------------------
	PROC do_noise
		M_push_all
		call clear_screen

		; Зберігаємо початковий стан динаміка
		in al, 61h
		push ax
		mov ah, 09h
		mov dx, offset standby
		int 21h

		or al, 00000011B	; Зміна стану на включений динамік (режим керування мікросхемою таймера)
		out 61h, al			; Занесення стану
		mov al, frequency	; Встановлюємо частоту (1.19МГц / frequency)
		out 42h, al			; Вмикаємо таймер, що буде подавати імпульси на динамік за заданою частотою
		call pause			; Виклик процедури очікування, під час виконання котрої в нас буде створюватись звук

		; Повертаємо початковий стан динаміка
		pop ax
		out 61h, al

		call clear_screen
		call draw_a_menu
		call highlight_current_option

		M_pop_all
		ret
		ENDP do_noise

	; ---------------------------------------------------------------------------------
	; Призначення: очікування
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC pause
		push cx
		
		; Робимо duration^2 циклів та сподіваємось, що це займе приблизно 1 секунду
		; Єкспериментальним методом було доведено, що виконання duration^2 циклів займає приблизно 1 секунду
		mov cx, duration
		loop1:
			push cx
			mov cx, duration
			loop2:
				loop loop2
				pop cx
			loop loop1
		
		pop cx
		ret
		ENDP pause

	; ---------------------------------------------------------------------------------
	; Призначення: обчислення виразу, та його виводу на екран
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC calculate
		M_push_all
		; Обнулюємо регістр АХ. Це не обов'язково, але про всяк випадок хай буде
		mov ax, 0

		; a1 + a2
		mov al, [a1]
		mov dl, [a2]
		call iadd
		; (a1 + a2) * a3
		imul [a3]
		; (a1 + a2) * a3 / a4
		idiv [a4]
		; (a1 + a2) * a3 / a4 + a5
		mov dl, [a5]
		call iadd

		; Перевіряємо, чи від'ємний наш результат
		cmp al, 0
		jns number_printer
		; Підготовка даних до виводу, якщо результат від'ємний
		minus_printer:
			neg ax
			mov ah, '-'

		; Вивід результату у консоль
		number_printer:
		; Конвертуємо результат у ASCII код нашого числа
		add al, 30h
		; Виводимо число у консоль
		mov [equation_message+equation_length], ah  ;занесення значення для виводу
		mov [equation_message+equation_length+1], al  ;занесення значення для виводу
		lea bp, [equation_message]
		M_write_results 

		M_pop_all
		ret
		ENDP calculate

	; ---------------------------------------------------------------------------------
	; Призначення: додавання із урахуванням знаку перед числом
	; Вхід:
	; AL <- доданок 1
	; DL <- доданок 2
	; Вихід:
	; AL <- результат
	; ---------------------------------------------------------------------------------
	PROC iadd
		; Перевіряємо знак першого доданку
		cmp al, 0
		js minus_
		jmp plus_
		; Перевіряємо знак другого доданку, якщо перший додатній
		plus_:
		cmp dl, 0
		js plus_minus
		jmp plus_plus
		; Перевіряємо знак другого доданку, якщо перший від'ємний
		minus_:
		cmp dl, 0
		js minus_minus
		jmp minus_plus_2

			; Рахуємо
			plus_plus:
			add al, dl
			jmp eq_end

			plus_minus:
			neg dl
			sub al, dl
			jmp eq_end

			minus_plus_2:
			neg al
			sub dl, al
			mov al, dl
			jmp eq_end

			minus_minus:
			neg al
			neg dl
			add al, dl
			neg al
			jmp eq_end

		eq_end:
		ret
		ENDP iadd

	
end Start