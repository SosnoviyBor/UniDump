; -----------------------------------------
; ЛР №8
; -----------------------------------------
; Архітектура комп'ютера
; Завдання: Псевдо-графічний інтерфейс
; ВУЗ: КНУУ "КПІ"
; Факультет: ФІОТ
; Курс: 1
; Група: ІТ-03
; -----------------------------------------
; Автори:	Букрєєв М.С.
;			Король К.В.
;			Федяй Б.В.
; Дата: 12/05/2021
; -----------------------------------------
IDEAL			; Директива - тип Асемблера tasm 
MODEL small		; Директива - тип моделі пам’яті 
STACK 2048		; Директива - розмір стеку 

; // MARK: Macros
; ==================================== Макроси ====================================
; ---------------------------------------------------------------------------------
; Призначення: ініціалізація програми
; ---------------------------------------------------------------------------------
MACRO M_init		; Макрос для ініціалізації. Його початок
	mov ax, @data	; @data ідентифікатор, що створюються директивою MODEL
	mov ds, ax		; Завантаження початку сегменту даних в регістр DS
	mov es, ax		; Завантаження початку сегменту даних в регістр ES
		mov al,1
	out 42h, al     ;ініціалізація таймера
	ENDM M_init		; Кінець макросу

; ---------------------------------------------------------------------------------
; Призначення: вихід із програми (із кодом 0)
; ---------------------------------------------------------------------------------
MACRO M_exit
	mov ah, 4ch
	mov al, 0
	int 21h
	ENDM M_exit

; ---------------------------------------------------------------------------------
; Призначення: запам'ятовування значень регістрів
; ---------------------------------------------------------------------------------
MACRO M_push_all
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	ENDM M_push_all

; ---------------------------------------------------------------------------------
; Призначення: повернення значень регістрів
; ---------------------------------------------------------------------------------
MACRO M_pop_all
	pop di
	pop si
	pop bp
	pop dx
	pop cx
	pop bx
	pop ax
	ENDM M_pop_all

; ---------------------------------------------------------------------------------
; Призначення: виведення результату процедури у консоль
; ---------------------------------------------------------------------------------
MACRO M_write_results
	mov ah, 13h					; Код функції (AH = 13h - Вивід символу у позиції курсору)
	mov al, 00h					; Код підфункції (0 = вивід кольору BL без зміщення курсору)
	mov dh, result_V_offset		; Строка виводу
	mov dl, result_H_offset		; Колонка виводу
	mov bl, COLOR_output		; Колір, що виводиться
	mov cx, output_length		; Кількість символів для відображення
	int 10h						; Переривання BIOS. Детальніше: http://www.codenet.ru/progr/dos/int_0009.php
	ENDM M_write_results

; ================================= Сегмент даних =================================
; // MARK: Dataseg
DATASEG
; ===== Змінні =====
menu db 201d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,187d
     db 186d,' View creators  ',186d
     db 186d,' Do noise       ',186d
     db 186d,' Solve equation ',186d
     db 200d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,205d,188d
help_message 	 db ' Arrows, ESC, Enter. You know it, its the same '
creators_message db ' Team 1 consists of Bukreev, Korol and Fedyay  '
equation_message db ' (-7+3)*2/4+1=                                 '

jukebox	db "                    ___                                          ___"
		db " __________________/  /                       __________________/  /"
		db "| _    _______    /  /                       | _    _______    /  / "
		db "|(_) .d########b. //)| _____________________ |(_) .d########b. //)| "
		db "|  .d############//  ||        _____        ||  .d############//  | "
		db '| .d######""####//b. ||() ||  [Team1]  || ()|| .d######""####//b. | '
		db "| 9######(  )#_//##P ||()|__|  | = |  |__|()|| 9######(  )#_//##P | "
		db "| 'b######++#/_/##d' ||() ||   | = |   || ()|| 'b######++#/_/##d' | "
		db '|  "9############P"  ||   ||   |___|   ||   ||  "9############P"  | '
		db '|  _"9a#######aP"    ||  _   _____..__   _  ||  _"9a#######aP"    | '
		db '| |_|  `""""""       || (_) |_____||__| (_) || |_|  `""""""       | '
		db "|  ___..___________  ||_____________________||  ___..___________  | "
		db "| |___||___________| |                       | |___||___________| | "
		db "|____________________|                       |____________________| "

a1 db -7
a2 db 3
a3 db 2
a4 db 4
a5 db 1

current_option db 1

; ===== Константи =====
output_length equ 47

frequency equ 20
duration equ 1000

equation_length equ 14

; 00h - black
; 10h - blue
; 20h - green
; 30h - light blue
; 40h - red
; 50h - purple
; 60h - brown
; 70h - grey
COLOR_background equ 00h
COLOR_menu equ 70h
COLOR_current_option equ 60h
COLOR_output equ 60h
; H - Horizontal
; V - Vertical
menu_H_length equ 18
menu_V_offset equ 1
menu_H_offset equ 1
menu_last_row equ menu_V_offset + 4
result_V_offset equ 7
result_H_offset equ 0
option_amount equ 3
console_length equ 184Fh
jukebox_H_length equ 68
jukebox_row_amount equ 14

; =================================== Сегмент коду ====================================
CODESEG
Start:
	; ===== Код програми =====
	M_init

	call clear_screen				; Очистка екрану
	call draw_a_menu				; Відображення меню (ця строка коду функціонально нічого не робить, але допомагає зорієнтуватись у програмі)
	call highlight_current_option	; Виділення активної опції

	lea bp, [help_message]			; Отримання адреси повідомлення із інструкцією
	M_write_results					; Виведення допоміжного тексту

	call ask_for_input				; Виклик зчитування з клавіатури та обробок

	M_exit

	; =================================== Процедури ===================================
	; ---------------------------------------------------------------------------------
	; Призначення: очищення та зафарбовуування екрану одним кольором
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC clear_screen
		M_push_all

		mov ah, 06h					; Код функції (очистити екран та зафарбувати його, якщо треба)
		mov al, 0					; Символ, що буде записуватись
		mov bh, COLOR_background	; Колір заливки
		mov cx, 0					; Початок території зафабування (CH, CL <- строка, колонка)
		mov dx, console_length		; Кінець території зафарбування (DH, DL <- строка, колонка)
		int 10h						; Переривання BIOS. Детальніше: http://www.codenet.ru/progr/dos/int_0009.php

		M_pop_all
		ret
		ENDP clear_screen


	; ---------------------------------------------------------------------------------
	; Призначення: відмальовування меню програми
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC draw_a_menu
		M_push_all

		mov ah, 13h						; Код функції (AH = 13h - Вивід символу у позиції курсору)
		mov al, 00h						; Код підфункції (0 = вивід кольору BL без зміщення курсору)
		mov dh, menu_V_offset			; Зміщення вікна меню по вертикалі
		mov dl, menu_H_offset			; Зміщення вікна меню по горизонталі
		mov bx, COLOR_menu				; Колір меню
		mov cx, menu_H_length			; Довжина строки
		mov si, 0						; Лічильник рядку (перериванням не використовується)

		menu_printer:
			lea bp, [menu+si]			; Запис адреси рядка, що буде записуватись до BP (BP - строка, що буде виводитись)
			int 10h						; Переривання BIOS. Детальніше http://www.codenet.ru/progr/dos/int_0009.php
			inc dh						; Перехід на наступний рядок
			add si, menu_H_length		; Збільшення лічильника рядків
			; Перевірка на кінець меню
			cmp dh, menu_last_row+1
			jne menu_printer

		M_pop_all
		ret
		ENDP draw_a_menu

	; ---------------------------------------------------------------------------------
	; Призначення: виділення активної опції іншим кольором
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC highlight_current_option
		M_push_all
		
		call draw_a_menu
		; Визначення, яку опцію треба виділити
		mov dh, [current_option]
		add dh, menu_V_offset
		mov dl, menu_H_offset+1
		; Кількість символів для відображення
		mov cx, menu_H_length-2
		; Визначення активної опції
		mov al, menu_H_length
		mov bl, [current_option]
		mul bl
		mov si, ax
		lea bp, [menu+si+1]
		; Колір активної опції
		mov bx, COLOR_current_option
		; Задання функції та підфункції
		mov ah, 13h
		mov al, 0
		; Переривання BIOS
		int 10h
		
		M_pop_all
		ret
		ENDP highlight_current_option

	; ---------------------------------------------------------------------------------
	; Призначення: реагування на нажимання конкретних клавіш
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC ask_for_input
		M_push_all
		;
		input:
			mov ah, 10h     ;функція зчитування з клавіатури
			int 16h
			cmp ah, 50h     ; Up
			je arrow_up
			cmp ah, 48h     ; Down
			je arrow_down
			cmp al, 0Dh     ; Enter
			je enter_
			cmp al, 1Bh     ; ESC
			je escape
			jmp input; повторення циклу

		arrow_down:
			; Перевіка, чи не на крайній опції ми знаходимось
			mov al, [current_option]
			cmp al, 1
			je input	; Не робимо нічого, якщо ми на крайній
			; Оновлення активного рядка
			dec al
			mov [current_option], al
			call highlight_current_option
			jmp input

		arrow_up:
		; Перевіка, чи не на крайній опції ми знаходимось
			mov al, [current_option]
			cmp al, option_amount
			je input	; Не робимо нічого, якщо ми на крайній
			; Оновлення активного рядка
			inc al
			mov [current_option], al
			call highlight_current_option
			jmp input

		enter_:
			call task_chooser	; Виклик процедури для виклику процедур
			jmp input

		escape:		;Вихід з программи
		M_pop_all
		ret
		ENDP ask_for_input

	; ---------------------------------------------------------------------------------
	; Призначення: вибір потрібної процедури на виконання
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC task_chooser
		M_push_all

		; Перевірка активної опції
		mov al, [current_option]
		cmp al, 1
		je task_1
		cmp al, 2
		je task_2
		cmp al, 3
		je task_3

		; Перша опція
		task_1:
		lea bp, [creators_message]
		M_write_results 
		jmp task_chooser_end

		; Друга опція
		task_2:
		call do_noise
		jmp task_chooser_end

		; Третя опція
		task_3:
		call calculate
		jmp task_chooser_end

		task_chooser_end:
		M_pop_all
		ret
		ENDP task_chooser

	; ---------------------------------------------------------------------------------
	; Призначення: програш звуку
	; Вхід:
	; frequency <- частота звуку
	; duration <- тривалість звуку
	; Вихід:
	; Максимально противний звук із колонок. Наслоджуйтесь
	; ---------------------------------------------------------------------------------
	PROC do_noise
		M_push_all
		call clear_screen
		call draw_a_jukebox

		; Зберігаємо початковий стан динаміка
		in al, 61h
		push ax

		or al, 00000011B	; Зміна стану на включений динамік (режим керування мікросхемою таймера)
		out 61h, al			; Занесення стану
		mov al, frequency	; Встановлюємо частоту (1.19МГц / frequency)
		out 42h, al			; Вмикаємо таймер, що буде подавати імпульси на динамік за заданою частотою
		call pause			; Виклик процедури очікування, під час виконання котрої в нас буде створюватись звук

		; Повертаємо початковий стан динаміка
		pop ax
		out 61h, al

		call clear_screen
		call draw_a_menu
		call highlight_current_option

		M_pop_all
		ret
		ENDP do_noise

	; ---------------------------------------------------------------------------------
	; Призначення: очікування
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC pause
		push cx
		
		; Робимо duration^2 циклів та сподіваємось, що це займе приблизно 1 секунду
		; Єкспериментальним методом було доведено, що виконання duration^2 циклів займає приблизно 1 секунду
		mov cx, duration
		loop1:
			push cx
			mov cx, duration
			loop2:
				loop loop2
				pop cx
			loop loop1
		
		pop cx
		ret
		ENDP pause

	; ---------------------------------------------------------------------------------
	; Призначення: вивід смішного бумбоксу под час програшу звуку
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC draw_a_jukebox
		
		; Все абсолютно те ж саме, що і в процедурі draw_a_menu
		mov ah, 13h
		mov al, 00h
		mov dh, 0
		mov dl, 0
		mov bx, COLOR_menu
		mov cx, jukebox_H_length
		mov si, 0

		jukebox_printer:
			lea bp, [jukebox+si]
			int 10h
			inc dh
			add si, jukebox_H_length
			cmp dh, jukebox_row_amount
			jne jukebox_printer

		ret
		ENDP draw_a_jukebox

	; ---------------------------------------------------------------------------------
	; Призначення: обчислення виразу, та його виводу на екран
	; Вхід: ---
	; Вихід: ---
	; ---------------------------------------------------------------------------------
	PROC calculate
		M_push_all
		; Обнулюємо регістр АХ. Це не обов'язково, але про всяк випадок хай буде
		mov ax, 0

		; a1 + a2
		mov al, [a1]
		mov dl, [a2]
		call iadd
		; (a1 + a2) * a3
		imul [a3]
		; (a1 + a2) * a3 / a4
		idiv [a4]
		; (a1 + a2) * a3 / a4 + a5
		mov dl, [a5]
		call iadd

		; Перевіряємо, чи від'ємний наш результат
		cmp al, 0
		jns number_printer
		; Підготовка даних до виводу, якщо результат від'ємний
		minus_printer:
			neg ax
			mov ah, '-'

		; Вивід результату у консоль
		number_printer:
		; Конвертуємо результат у ASCII код нашого числа
		add al, 30h
		; Виводимо число у консоль
		mov [equation_message+equation_length], ah  ;занесення значення для виводу
		mov [equation_message+equation_length+1], al  ;занесення значення для виводу
		lea bp, [equation_message]
		M_write_results 

		M_pop_all
		ret
		ENDP calculate

	; ---------------------------------------------------------------------------------
	; Призначення: додавання із урахуванням знаку перед числом
	; Вхід:
	; AL <- доданок 1
	; DL <- доданок 2
	; Вихід:
	; AL <- результат
	; ---------------------------------------------------------------------------------
	PROC iadd
		; Перевіряємо знак першого доданку
		cmp al, 0
		js minus_
		jmp plus_
		; Перевіряємо знак другого доданку, якщо перший додатній
		plus_:
		cmp dl, 0
		js plus_minus
		jmp plus_plus
		; Перевіряємо знак другого доданку, якщо перший від'ємний
		minus_:
		cmp dl, 0
		js minus_minus
		jmp minus_plus_2

			; Рахуємо
			plus_plus:
			add al, dl
			jmp eq_end

			plus_minus:
			neg dl
			sub al, dl
			jmp eq_end

			minus_plus_2:
			neg al
			sub dl, al
			mov al, dl
			jmp eq_end

			minus_minus:
			neg al
			neg dl
			add al, dl
			neg al
			jmp eq_end

		eq_end:
		ret
		ENDP iadd

	
end Start