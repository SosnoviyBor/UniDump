[org 0x7c00] ; Початок BOOT сектора
[bits 16]



mov dx, custom_int_code
; ---------- Отримання адреси переривання, що будемо замінювати ----------
mov di, [custom_int_code]

call GetIntVals

mov [old_IP], bx
mov [old_CS], es
; ------------- Заміна переривання на потрібну нам процедуру -------------
mov di, [custom_int_code]
mov dx, Printer
mov ax, 0
mov es, ax

call SetIntVals
; ----------------------- Виклик цього преривання ------------------------
int 33h
; ------------- Повернення початкового функціоналу прериванню ------------
mov di, [custom_int_code]
mov dx, [old_IP]
mov ax, [old_CS]
mov es, ax

call SetIntVals
; ------------------------------------------------------------------------
jmp $

; ================================ Процедури ================================
; ----------------------------------------------------------------------------------
; Призначення: Вивід строки тексту у консоль
; Вхід:
;	message <- Змінна, що у кінці обов'язково має символ-термінатор
; Вихід: ---
; ----------------------------------------------------------------------------------
Printer:
	push ax
	push dx

		; Очищення консолі
	mov ax, 03h
	int 10h
	; Вивід рядку на екран
	mov si, message
	call printf

	pop dx
	pop ax
	iret

; ----------------------------------------------------------------------------------
; Призначення: Отримання логічної адреси процедури обробки переривання за номером вектора переривання
; Вхід:
; 	DI <- номер вектора переривання
; Вихід:
; 	BX <- Ефективна адреса (IP) обробки переривання
; 	ES <- Сегмент процедури (CS) обробки переривання
; ----------------------------------------------------------------------------------
GetIntVals:
	push ax
	push di

	shl	di, 2 				; DI <- DI * 4
	mov	bx, [di] 			; В BX записуємо зміщення процедруи обробника, що знаходиться у векторі переривання
	mov	ax, [di + 2] 		; В AX записуємо сегмент процедруи обробника, що знаходиться у векторі переривання
	mov	es, ax				; ES <- AX

	pop	di
	pop	ax
	ret

; ----------------------------------------------------------------------------------
; Призначення: Установка на номер вектора нової функції обробника. Зміна функціоналу прерівання за логічною адресою
; Вхід:
; 	DI - номер переривання де буде нова процедура
; 	DX - ефективна адреса нового обробника (IP)
; 	ES - адреса сегмента нового обробника (CS)
; Вихід: ---
; ----------------------------------------------------------------------------------
SetIntVals:
	cli 					; Заборона апаратних переривань
	push ax
	push di
	push ds

	mov	ax, 0 				; AX <- 0
	mov ds, ax				; DS <- 0. Інакше ми значення будемо встановлювати бог знає куди
	shl	di, 2 				; DI <- DI * 4
	mov	[di], dx 			; Перезаписуємо зміщення (IP) у векторі переривання 
	mov	[di + 2], es 		; Перезаписуємо сегмент (CS) у векторі переривання 

	pop	ds
	pop	di
	pop	ax
	sti 					; Дозвіл апаратних переривань
	ret

; ----------------------------------------------------------------------------------
; Призначення: вивід текстовоїстроки у консоль
; Вхід: 
; 	SI - зміщення, по якому знаходиться початок рядка для друку
; Вихід: ---
; ----------------------------------------------------------------------------------
printf:
	pusha

	; Записуємо в AL поточний символ по зміщенню SI
	print_loop:
		mov al, [si]
		cmp al, "$"
		jne print_char		; Якщо це ще не кінець рядка
		jmp printf_end

	print_char:
		mov ah, 0x0e
		int 0x10			; Друкуємо символ, що знаходиться в AL
		add si, 1 			; Переходимо до наступного символа в рядку
		jmp print_loop

	printf_end:
	popa
	ret



; ================================ Дані ================================
message db 10, 13, "Team 1: Brazhnik, Korol, Fedyay :)", "$"
custom_int_code dw 33h	; 33h = 51d
old_IP dw 0
old_CS dw 0
; ----------------------------------------------------------------------------------
times 510-($-$$) db 0 ; Відступ у сегменті бутлоадера (його розмір - 512 байт, тому треба дозаповнити пам'ять к-стю байт, рівною 512 мінус поточний розмір нашої програми)
dw 0xaa55 ; Спеціальне число, необхідне вкінці програми